<!doctype html>
<html class="no-js" lang="en" data-content_root="../../../">
  <head><meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="color-scheme" content="light dark"><link rel="index" title="Index" href="../../../genindex.html"><link rel="search" title="Search" href="../../../search.html">

    <!-- Generated with Sphinx 8.2.3 and Furo 2025.09.25 -->
        <title>protomotions.utils.scene_lib - ProtoMotions documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=d111a655" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo.css?v=580074bf" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo-extensions.css?v=8dab3a3b" />
    
    


<style>
  body {
    --color-code-background: #f2f2f2;
  --color-code-foreground: #1e1e1e;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle site navigation sidebar">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc" aria-label="Toggle table of contents sidebar">
<label class="overlay sidebar-overlay" for="__navigation"></label>
<label class="overlay toc-overlay" for="__toc"></label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <span class="icon"><svg><use href="#svg-menu"></use></svg></span>
      </label>
    </div>
    <div class="header-center">
      <a href="../../../index.html"><div class="brand">ProtoMotions  documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle" aria-label="Toggle Light / Dark / Auto color theme">
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <span class="icon"><svg><use href="#svg-toc"></use></svg></span>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../../index.html">
  
  <span class="sidebar-brand-text">ProtoMotions  documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../../../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started/quickstart.html">Quick Start</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started/how_it_works.html">How It Works</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../user_guide/training.html">Training Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_guide/evaluation.html">Evaluation Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_guide/configuration.html">Configuration System</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_guide/algorithms.html">Algorithms</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tutorials</span></p>
<ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../tutorials/index.html">Tutorials</a><input aria-label="Toggle navigation of Tutorials" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorials/code_tutorials.html">Code Tutorials (Progressive Series)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorials/training_workflow.html">Training Workflow Tutorial</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorials/motion_tracking.html">Motion Tracking Tutorial</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorials/custom_robot.html">Custom Robot Tutorial</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Data Preparation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/amass_parsing.html">AMASS Dataset Parsing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/retargeting_motions.html">Retargeting Motion Data Between Humanoids</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Examples</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/experiments.html">Experiment Configurations</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../api_reference/index.html">API Reference</a><input aria-label="Toggle navigation of API Reference" class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../api_reference/protomotions.agents.html">protomotions.agents package</a><input aria-label="Toggle navigation of protomotions.agents package" class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../../api_reference/protomotions.agents.amp.html">protomotions.agents.amp package</a><input aria-label="Toggle navigation of protomotions.agents.amp package" class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" role="switch" type="checkbox"/><label for="toctree-checkbox-4"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../api_reference/protomotions.agents.amp.agent.html">protomotions.agents.amp.agent module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api_reference/protomotions.agents.amp.config.html">protomotions.agents.amp.config module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api_reference/protomotions.agents.amp.model.html">protomotions.agents.amp.model module</a></li>
</ul>
</li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../../api_reference/protomotions.agents.ase.html">protomotions.agents.ase package</a><input aria-label="Toggle navigation of protomotions.agents.ase package" class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" role="switch" type="checkbox"/><label for="toctree-checkbox-5"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../api_reference/protomotions.agents.ase.agent.html">protomotions.agents.ase.agent module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api_reference/protomotions.agents.ase.config.html">protomotions.agents.ase.config module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api_reference/protomotions.agents.ase.model.html">protomotions.agents.ase.model module</a></li>
</ul>
</li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../../api_reference/protomotions.agents.base_agent.html">protomotions.agents.base_agent package</a><input aria-label="Toggle navigation of protomotions.agents.base_agent package" class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" role="switch" type="checkbox"/><label for="toctree-checkbox-6"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../api_reference/protomotions.agents.base_agent.agent.html">protomotions.agents.base_agent.agent module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api_reference/protomotions.agents.base_agent.config.html">protomotions.agents.base_agent.config module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api_reference/protomotions.agents.base_agent.model.html">protomotions.agents.base_agent.model module</a></li>
</ul>
</li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../../api_reference/protomotions.agents.callbacks.html">protomotions.agents.callbacks package</a><input aria-label="Toggle navigation of protomotions.agents.callbacks package" class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" role="switch" type="checkbox"/><label for="toctree-checkbox-7"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../api_reference/protomotions.agents.callbacks.one_logger.html">protomotions.agents.callbacks.one_logger module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api_reference/protomotions.agents.callbacks.slurm_autoresume_adlr.html">protomotions.agents.callbacks.slurm_autoresume_adlr module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api_reference/protomotions.agents.callbacks.slurm_autoresume_srun.html">protomotions.agents.callbacks.slurm_autoresume_srun module</a></li>
</ul>
</li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../../api_reference/protomotions.agents.common.html">protomotions.agents.common package</a><input aria-label="Toggle navigation of protomotions.agents.common package" class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" role="switch" type="checkbox"/><label for="toctree-checkbox-8"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../api_reference/protomotions.agents.common.common.html">protomotions.agents.common.common module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api_reference/protomotions.agents.common.config.html">protomotions.agents.common.config module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api_reference/protomotions.agents.common.mlp.html">protomotions.agents.common.mlp module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api_reference/protomotions.agents.common.transformer.html">protomotions.agents.common.transformer module</a></li>
</ul>
</li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../../api_reference/protomotions.agents.evaluators.html">protomotions.agents.evaluators package</a><input aria-label="Toggle navigation of protomotions.agents.evaluators package" class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" role="switch" type="checkbox"/><label for="toctree-checkbox-9"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../api_reference/protomotions.agents.evaluators.base_evaluator.html">protomotions.agents.evaluators.base_evaluator module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api_reference/protomotions.agents.evaluators.config.html">protomotions.agents.evaluators.config module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api_reference/protomotions.agents.evaluators.metrics.html">protomotions.agents.evaluators.metrics module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api_reference/protomotions.agents.evaluators.mimic_evaluator.html">protomotions.agents.evaluators.mimic_evaluator module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api_reference/protomotions.agents.evaluators.smoothness_evaluator.html">protomotions.agents.evaluators.smoothness_evaluator module</a></li>
</ul>
</li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../../api_reference/protomotions.agents.masked_mimic.html">protomotions.agents.masked_mimic package</a><input aria-label="Toggle navigation of protomotions.agents.masked_mimic package" class="toctree-checkbox" id="toctree-checkbox-10" name="toctree-checkbox-10" role="switch" type="checkbox"/><label for="toctree-checkbox-10"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../api_reference/protomotions.agents.masked_mimic.agent.html">protomotions.agents.masked_mimic.agent module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api_reference/protomotions.agents.masked_mimic.config.html">protomotions.agents.masked_mimic.config module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api_reference/protomotions.agents.masked_mimic.model.html">protomotions.agents.masked_mimic.model module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../api_reference/protomotions.agents.mimic.html">protomotions.agents.mimic package</a></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../../api_reference/protomotions.agents.ppo.html">protomotions.agents.ppo package</a><input aria-label="Toggle navigation of protomotions.agents.ppo package" class="toctree-checkbox" id="toctree-checkbox-11" name="toctree-checkbox-11" role="switch" type="checkbox"/><label for="toctree-checkbox-11"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../api_reference/protomotions.agents.ppo.agent.html">protomotions.agents.ppo.agent module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api_reference/protomotions.agents.ppo.config.html">protomotions.agents.ppo.config module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api_reference/protomotions.agents.ppo.model.html">protomotions.agents.ppo.model module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api_reference/protomotions.agents.ppo.utils.html">protomotions.agents.ppo.utils module</a></li>
</ul>
</li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../../api_reference/protomotions.agents.utils.html">protomotions.agents.utils package</a><input aria-label="Toggle navigation of protomotions.agents.utils package" class="toctree-checkbox" id="toctree-checkbox-12" name="toctree-checkbox-12" role="switch" type="checkbox"/><label for="toctree-checkbox-12"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../api_reference/protomotions.agents.utils.average_meter.html">protomotions.agents.utils.average_meter module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api_reference/protomotions.agents.utils.data_utils.html">protomotions.agents.utils.data_utils module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api_reference/protomotions.agents.utils.model_utils.html">protomotions.agents.utils.model_utils module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api_reference/protomotions.agents.utils.replay_buffer.html">protomotions.agents.utils.replay_buffer module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api_reference/protomotions.agents.utils.running_mean_std.html">protomotions.agents.utils.running_mean_std module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api_reference/protomotions.agents.utils.step_tracker.html">protomotions.agents.utils.step_tracker module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api_reference/protomotions.agents.utils.time_report.html">protomotions.agents.utils.time_report module</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../api_reference/protomotions.envs.html">protomotions.envs package</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../api_reference/protomotions.simulator.html">protomotions.simulator package</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../api_reference/protomotions.robot_configs.html">protomotions.robot_configs module</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../api_reference/protomotions.utils.html">protomotions.utils package</a><input aria-label="Toggle navigation of protomotions.utils package" class="toctree-checkbox" id="toctree-checkbox-13" name="toctree-checkbox-13" role="switch" type="checkbox"/><label for="toctree-checkbox-13"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../api_reference/protomotions.utils.common.html">protomotions.utils.common module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api_reference/protomotions.utils.config_builder.html">protomotions.utils.config_builder module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api_reference/protomotions.utils.config_utils.html">protomotions.utils.config_utils module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api_reference/protomotions.utils.motion_lib.html">protomotions.utils.motion_lib module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api_reference/protomotions.utils.motion_interpolation_utils.html">protomotions.utils.motion_interpolation_utils module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api_reference/protomotions.utils.pose_lib.html">protomotions.utils.pose_lib module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api_reference/protomotions.utils.scene_lib.html">protomotions.utils.scene_lib module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api_reference/protomotions.utils.simulator_imports.html">protomotions.utils.simulator_imports module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../api_reference/scripts.html">Training and Evaluation Scripts</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Community</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../community.html">Community Showcase</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle" aria-label="Toggle Light / Dark / Auto color theme">
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
            <span class="icon"><svg><use href="#svg-toc"></use></svg></span>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <h1>Source code for protomotions.utils.scene_lib</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Scene library for managing objects and scenes in environments.</span>

<span class="sd">This module provides the SceneLib class which manages object spawning, placement,</span>
<span class="sd">and interaction in simulation environments. It supports both static and dynamic objects,</span>
<span class="sd">motion-controlled objects, and complex multi-object scenes.</span>


<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">random</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">copy</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">MISSING</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Union</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">isaac_utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">rotations</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">trimesh</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">enum</span><span class="w"> </span><span class="kn">import</span> <span class="n">Enum</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">protomotions.utils.config_builder</span><span class="w"> </span><span class="kn">import</span> <span class="n">ConfigBuilder</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">protomotions.utils.motion_interpolation_utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">calc_frame_blend</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">protomotions.envs.base_env.env_utils.object_utils</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">as_mesh</span><span class="p">,</span>
    <span class="n">compute_bounding_box</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">protomotions.simulator.base_simulator.simulator_state</span><span class="w"> </span><span class="kn">import</span> <span class="n">ObjectState</span><span class="p">,</span> <span class="n">StateConversion</span>


<span class="kn">from</span><span class="w"> </span><span class="nn">protomotions.envs.base_env.env_utils.terrains.terrain</span><span class="w"> </span><span class="kn">import</span> <span class="n">Terrain</span>

<span class="c1"># Setup logging</span>
<span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">)</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<div class="viewcode-block" id="ObjectOptions">
<a class="viewcode-back" href="../../../api_reference/protomotions.utils.scene_lib.html#protomotions.utils.scene_lib.ObjectOptions">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">ObjectOptions</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Contains options for configuring object properties in the simulator.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">fix_base_link</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="n">MISSING</span><span class="p">)</span>
    <span class="n">vhacd_enabled</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">vhacd_params</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span>
        <span class="n">default_factory</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;resolution&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;max_convex_hulls&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;max_num_vertices_per_ch&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">)</span>
    <span class="n">density</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">angular_damping</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">linear_damping</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">max_angular_velocity</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">texture_path</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Path to texture file</span>

<div class="viewcode-block" id="ObjectOptions.to_dict">
<a class="viewcode-back" href="../../../api_reference/protomotions.utils.scene_lib.html#protomotions.utils.scene_lib.ObjectOptions.to_dict">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert options to a dictionary, excluding None values.</span>
<span class="sd">        </span>
<span class="sd">        This method recursively filters out None values from nested dictionaries</span>
<span class="sd">        to prevent type errors in simulator backends that don&#39;t accept None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">options_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">field_name</span><span class="p">,</span> <span class="n">field_value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">field_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="c1"># Recursively filter None values from nested dictionaries</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">field_value</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">filtered_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">field_value</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">}</span>
                <span class="c1"># Only include the dict if it has non-None values</span>
                <span class="k">if</span> <span class="n">filtered_dict</span><span class="p">:</span>
                    <span class="n">options_dict</span><span class="p">[</span><span class="n">field_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">filtered_dict</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">options_dict</span><span class="p">[</span><span class="n">field_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">field_value</span>
        <span class="k">return</span> <span class="n">options_dict</span></div>
</div>



<div class="viewcode-block" id="SceneObject">
<a class="viewcode-back" href="../../../api_reference/protomotions.utils.scene_lib.html#protomotions.utils.scene_lib.SceneObject">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">SceneObject</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Represents an object inside a scene.</span>

<span class="sd">    The object can be static or have motion:</span>
<span class="sd">    - Static object: translation is a 3D vector and rotation is a 4D quaternion</span>
<span class="sd">    - Moving object: translation is a sequence of 3D vectors and rotation is a sequence of 4D quaternions</span>

<span class="sd">    Supported input formats (all converted to torch.Tensor internally):</span>
<span class="sd">    - Static: tuple(3), list(3), numpy.ndarray(3), torch.Tensor(3)</span>
<span class="sd">    - Motion: list[tuple(3)], numpy.ndarray(N,3), torch.Tensor(N,3)</span>

<span class="sd">    For moving objects, the first frame defines the initial state, and subsequent frames</span>
<span class="sd">    define the motion path. Both translation and rotation must have the same number of frames.</span>

<span class="sd">    fps: Frames per second for motion data. Must be defined if the object has motion.</span>
<span class="sd">         For static objects, fps defaults to 1.0.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">translation</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
        <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]],</span>
        <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="p">]</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="n">MISSING</span><span class="p">)</span>
    <span class="n">rotation</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
        <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]],</span>
        <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="p">]</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="n">MISSING</span><span class="p">)</span>
    <span class="n">options</span><span class="p">:</span> <span class="n">ObjectOptions</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="n">ObjectOptions</span><span class="p">)</span>
    <span class="n">fps</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">object_dims</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="kc">None</span>  <span class="c1"># min_x, max_x, min_y, max_y, min_z, max_z</span>
    <span class="p">)</span>
    <span class="n">object_pointcloud</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">object_pointcloud_normals</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Normals corresponding to each point in the pointcloud</span>
    <span class="n">is_first_instance</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="p">(</span>
        <span class="kc">True</span>  <span class="c1"># Whether this is the first instance of this object type</span>
    <span class="p">)</span>
    <span class="n">first_instance_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="kc">None</span>  <span class="c1"># ID of the first instance of this object type, some sims can ultilize this to make loading duplicate objects more efficient</span>
    <span class="p">)</span>
    <span class="n">instance_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Unique ID for this object instance</span>

<div class="viewcode-block" id="SceneObject.__post_init__">
<a class="viewcode-back" href="../../../api_reference/protomotions.utils.scene_lib.html#protomotions.utils.scene_lib.SceneObject.__post_init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">__post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Validate data and convert translation and rotation to PyTorch tensors.</span>
<span class="sd">        Sets default values for fps based on whether the object has motion.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Convert translation to tensor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">translation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_to_tensor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">translation</span><span class="p">,</span> <span class="n">expected_dim</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

        <span class="c1"># Convert rotation to tensor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rotation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_to_tensor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rotation</span><span class="p">,</span> <span class="n">expected_dim</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>

        <span class="c1"># Validate shapes match</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">translation</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># This is motion data with multiple frames</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">translation</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotation</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Translation (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">translation</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> frames) and rotation (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">rotation</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> frames) must have the same number of frames&quot;</span>

            <span class="c1"># For objects with motion, fps must be defined</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="p">),</span> <span class="s2">&quot;FPS must be defined for objects with motion data&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Static object, set default fps</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fps</span> <span class="o">=</span> <span class="mf">1.0</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_convert_to_tensor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">expected_dim</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert input data to PyTorch tensor with appropriate shape.</span>

<span class="sd">        Args:</span>
<span class="sd">            data: Input data (tuple, list, numpy array, or torch tensor)</span>
<span class="sd">            expected_dim: Expected dimension of each vector (3 for translation, 4 for rotation)</span>

<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: Data converted to tensor with proper shape</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">device</span> <span class="o">=</span> <span class="s2">&quot;cpu&quot;</span>  <span class="c1"># Default device</span>

        <span class="c1"># Handle list of tuples/lists for motion data</span>
        <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">is_tensor</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
            <span class="c1"># If data is already a tensor, clone and detach to get an independent copy</span>
            <span class="c1"># Then ensure correct dtype and device, and reshape</span>
            <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span>
                <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">expected_dim</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If data is not a tensor (e.g., list, tuple, numpy array), use torch.tensor</span>
            <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span>
                <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">expected_dim</span>
            <span class="p">)</span>

<div class="viewcode-block" id="SceneObject.has_motion">
<a class="viewcode-back" href="../../../api_reference/protomotions.utils.scene_lib.html#protomotions.utils.scene_lib.SceneObject.has_motion">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">has_motion</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if the object has motion data (multiple frames).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">translation</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">start_pose</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ObjectState</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the initial pose (first frame) of the object as an ObjectState.</span>

<span class="sd">        For static objects, returns the single pose.</span>
<span class="sd">        For objects with motion, returns the first frame of motion.</span>

<span class="sd">        Returns:</span>
<span class="sd">            ObjectState: Object state containing translation and rotation tensors,</span>
<span class="sd">                        both with shape [1, 3] and [1, 4] respectively (batched format).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">translation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">translation</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">rotation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotation</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">ObjectState</span><span class="p">(</span><span class="n">root_pos</span><span class="o">=</span><span class="n">translation</span><span class="p">,</span> <span class="n">root_rot</span><span class="o">=</span><span class="n">rotation</span><span class="p">,</span> <span class="n">state_conversion</span><span class="o">=</span><span class="n">StateConversion</span><span class="o">.</span><span class="n">COMMON</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">object_identifier</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate a unique identifier for the object&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Subclasses must implement object_identifier&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="SceneObject.calculate_dimensions">
<a class="viewcode-back" href="../../../api_reference/protomotions.utils.scene_lib.html#protomotions.utils.scene_lib.SceneObject.calculate_dimensions">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the object dimensions - to be implemented by subclasses&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Subclasses must implement calculate_dimensions&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="SceneObject.compute_pointcloud">
<a class="viewcode-back" href="../../../api_reference/protomotions.utils.scene_lib.html#protomotions.utils.scene_lib.SceneObject.compute_pointcloud">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_pointcloud</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pointcloud_samples_per_object</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the pointcloud for the object&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Subclasses must implement compute_pointcloud&quot;</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="MeshSceneObject">
<a class="viewcode-back" href="../../../api_reference/protomotions.utils.scene_lib.html#protomotions.utils.scene_lib.MeshSceneObject">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">MeshSceneObject</span><span class="p">(</span><span class="n">SceneObject</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Represents a mesh object specified via a file path.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">object_path</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="MeshSceneObject.__post_init__">
<a class="viewcode-back" href="../../../api_reference/protomotions.utils.scene_lib.html#protomotions.utils.scene_lib.MeshSceneObject.__post_init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">__post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Validate that object_path is specified, compute dimensions&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">object_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;object_path must be specified for MeshSceneObject&quot;</span><span class="p">)</span>

        <span class="c1"># Calculate dimensions if not provided</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">object_dims</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">object_dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_dimensions</span><span class="p">()</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__post_init__</span><span class="p">()</span></div>


<div class="viewcode-block" id="MeshSceneObject.calculate_dimensions">
<a class="viewcode-back" href="../../../api_reference/protomotions.utils.scene_lib.html#protomotions.utils.scene_lib.MeshSceneObject.calculate_dimensions">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the dimensions from the mesh file&quot;&quot;&quot;</span>

        <span class="n">obj_path</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">object_path</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.urdf&quot;</span><span class="p">,</span> <span class="s2">&quot;.obj&quot;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.usda&quot;</span><span class="p">,</span> <span class="s2">&quot;.obj&quot;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.usd&quot;</span><span class="p">,</span> <span class="s2">&quot;.obj&quot;</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">stl_path</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">object_path</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.urdf&quot;</span><span class="p">,</span> <span class="s2">&quot;.stl&quot;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.usda&quot;</span><span class="p">,</span> <span class="s2">&quot;.stl&quot;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.usd&quot;</span><span class="p">,</span> <span class="s2">&quot;.stl&quot;</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">ply_path</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">object_path</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.urdf&quot;</span><span class="p">,</span> <span class="s2">&quot;.ply&quot;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.usda&quot;</span><span class="p">,</span> <span class="s2">&quot;.ply&quot;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.usd&quot;</span><span class="p">,</span> <span class="s2">&quot;.ply&quot;</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">obj_path</span><span class="p">)</span>
            <span class="ow">or</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">stl_path</span><span class="p">)</span>
            <span class="ow">or</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">ply_path</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">obj_path</span><span class="p">):</span>
                <span class="n">mesh_path</span> <span class="o">=</span> <span class="n">obj_path</span>
            <span class="k">elif</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">stl_path</span><span class="p">):</span>
                <span class="n">mesh_path</span> <span class="o">=</span> <span class="n">stl_path</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mesh_path</span> <span class="o">=</span> <span class="n">ply_path</span>
            <span class="n">mesh</span> <span class="o">=</span> <span class="n">as_mesh</span><span class="p">(</span><span class="n">trimesh</span><span class="o">.</span><span class="n">load_mesh</span><span class="p">(</span><span class="n">mesh_path</span><span class="p">))</span>
            <span class="n">w_x</span><span class="p">,</span> <span class="n">w_y</span><span class="p">,</span> <span class="n">w_z</span><span class="p">,</span> <span class="n">m_x</span><span class="p">,</span> <span class="n">m_y</span><span class="p">,</span> <span class="n">m_z</span> <span class="o">=</span> <span class="n">compute_bounding_box</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Object file not found: </span><span class="si">{</span><span class="n">obj_path</span><span class="si">}</span><span class="s2"> / </span><span class="si">{</span><span class="n">stl_path</span><span class="si">}</span><span class="s2"> / </span><span class="si">{</span><span class="n">ply_path</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="n">min_x</span> <span class="o">=</span> <span class="n">m_x</span>
        <span class="n">max_x</span> <span class="o">=</span> <span class="n">min_x</span> <span class="o">+</span> <span class="n">w_x</span>
        <span class="n">min_y</span> <span class="o">=</span> <span class="n">m_y</span>
        <span class="n">max_y</span> <span class="o">=</span> <span class="n">min_y</span> <span class="o">+</span> <span class="n">w_y</span>
        <span class="n">min_z</span> <span class="o">=</span> <span class="n">m_z</span>
        <span class="n">max_z</span> <span class="o">=</span> <span class="n">min_z</span> <span class="o">+</span> <span class="n">w_z</span>

        <span class="k">return</span> <span class="n">min_x</span><span class="p">,</span> <span class="n">max_x</span><span class="p">,</span> <span class="n">min_y</span><span class="p">,</span> <span class="n">max_y</span><span class="p">,</span> <span class="n">min_z</span><span class="p">,</span> <span class="n">max_z</span></div>


<div class="viewcode-block" id="MeshSceneObject.compute_pointcloud">
<a class="viewcode-back" href="../../../api_reference/protomotions.utils.scene_lib.html#protomotions.utils.scene_lib.MeshSceneObject.compute_pointcloud">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_pointcloud</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pointcloud_samples_per_object</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the pointcloud for the object&quot;&quot;&quot;</span>
        <span class="n">obj_path</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">object_path</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.urdf&quot;</span><span class="p">,</span> <span class="s2">&quot;.obj&quot;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.usda&quot;</span><span class="p">,</span> <span class="s2">&quot;.obj&quot;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.usd&quot;</span><span class="p">,</span> <span class="s2">&quot;.obj&quot;</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">stl_path</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">object_path</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.urdf&quot;</span><span class="p">,</span> <span class="s2">&quot;.stl&quot;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.usda&quot;</span><span class="p">,</span> <span class="s2">&quot;.stl&quot;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.usd&quot;</span><span class="p">,</span> <span class="s2">&quot;.stl&quot;</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">ply_path</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">object_path</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.urdf&quot;</span><span class="p">,</span> <span class="s2">&quot;.ply&quot;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.usda&quot;</span><span class="p">,</span> <span class="s2">&quot;.ply&quot;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.usd&quot;</span><span class="p">,</span> <span class="s2">&quot;.ply&quot;</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">obj_path</span><span class="p">)</span>
            <span class="ow">or</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">stl_path</span><span class="p">)</span>
            <span class="ow">or</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">ply_path</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">obj_path</span><span class="p">):</span>
                <span class="n">mesh_path</span> <span class="o">=</span> <span class="n">obj_path</span>
            <span class="k">elif</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">stl_path</span><span class="p">):</span>
                <span class="n">mesh_path</span> <span class="o">=</span> <span class="n">stl_path</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mesh_path</span> <span class="o">=</span> <span class="n">ply_path</span>
            <span class="n">mesh</span> <span class="o">=</span> <span class="n">as_mesh</span><span class="p">(</span><span class="n">trimesh</span><span class="o">.</span><span class="n">load_mesh</span><span class="p">(</span><span class="n">mesh_path</span><span class="p">))</span>
            <span class="c1"># Sample points evenly from the mesh surface and get face indices</span>
            <span class="n">point_cloud_np</span><span class="p">,</span> <span class="n">face_indices</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">sample</span><span class="o">.</span><span class="n">sample_surface_even</span><span class="p">(</span>
                <span class="n">mesh</span><span class="p">,</span> <span class="n">pointcloud_samples_per_object</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">point_cloud_np</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">pointcloud_samples_per_object</span><span class="p">:</span>
                <span class="c1"># Even spacing uses rejection sampling, as a result it may return less points than requested</span>
                <span class="c1"># we add the extra points by randomly sampling the mesh surface again</span>
                <span class="n">missing_points</span> <span class="o">=</span> <span class="n">pointcloud_samples_per_object</span> <span class="o">-</span> <span class="n">point_cloud_np</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">extra_points_np</span><span class="p">,</span> <span class="n">extra_face_indices</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">sample</span><span class="o">.</span><span class="n">sample_surface</span><span class="p">(</span>
                    <span class="n">mesh</span><span class="p">,</span> <span class="n">missing_points</span>
                <span class="p">)</span>
                <span class="n">point_cloud_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">point_cloud_np</span><span class="p">,</span> <span class="n">extra_points_np</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">face_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">face_indices</span><span class="p">,</span> <span class="n">extra_face_indices</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="c1"># Get face normals corresponding to the sampled points</span>
            <span class="n">face_normals</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">face_normals</span><span class="p">[</span><span class="n">face_indices</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Object file not found: </span><span class="si">{</span><span class="n">obj_path</span><span class="si">}</span><span class="s2"> / </span><span class="si">{</span><span class="n">stl_path</span><span class="si">}</span><span class="s2"> / </span><span class="si">{</span><span class="n">ply_path</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">object_pointcloud</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">point_cloud_np</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">object_pointcloud_normals</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">face_normals</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">object_identifier</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Use object_path as the unique identifier for mesh objects&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">object_path</span></div>



<div class="viewcode-block" id="PrimitiveSceneObject">
<a class="viewcode-back" href="../../../api_reference/protomotions.utils.scene_lib.html#protomotions.utils.scene_lib.PrimitiveSceneObject">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">PrimitiveSceneObject</span><span class="p">(</span><span class="n">SceneObject</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for primitive shape objects.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Calculate dimensions if not provided</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">object_dims</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">object_dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_dimensions</span><span class="p">()</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__post_init__</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">object_identifier</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate a unique identifier for primitive shapes based on type and dimensions&quot;&quot;&quot;</span>
        <span class="c1"># Each subclass should implement this method</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Subclasses must implement object_identifier&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="BoxSceneObject">
<a class="viewcode-back" href="../../../api_reference/protomotions.utils.scene_lib.html#protomotions.utils.scene_lib.BoxSceneObject">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">BoxSceneObject</span><span class="p">(</span><span class="n">PrimitiveSceneObject</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Represents a box primitive shape.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">width</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">depth</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">height</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="BoxSceneObject.__post_init__">
<a class="viewcode-back" href="../../../api_reference/protomotions.utils.scene_lib.html#protomotions.utils.scene_lib.BoxSceneObject.__post_init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">__post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Validate dimensions&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">dim</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">depth</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">height</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Box shape requires width, depth, and height dimensions&quot;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__post_init__</span><span class="p">()</span></div>


<div class="viewcode-block" id="BoxSceneObject.calculate_dimensions">
<a class="viewcode-back" href="../../../api_reference/protomotions.utils.scene_lib.html#protomotions.utils.scene_lib.BoxSceneObject.calculate_dimensions">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate box dimensions&quot;&quot;&quot;</span>
        <span class="n">min_x</span><span class="p">,</span> <span class="n">max_x</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">min_y</span><span class="p">,</span> <span class="n">max_y</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">depth</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">depth</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">min_z</span><span class="p">,</span> <span class="n">max_z</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">height</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">min_x</span><span class="p">,</span> <span class="n">max_x</span><span class="p">,</span> <span class="n">min_y</span><span class="p">,</span> <span class="n">max_y</span><span class="p">,</span> <span class="n">min_z</span><span class="p">,</span> <span class="n">max_z</span><span class="p">)</span></div>


<div class="viewcode-block" id="BoxSceneObject.compute_pointcloud">
<a class="viewcode-back" href="../../../api_reference/protomotions.utils.scene_lib.html#protomotions.utils.scene_lib.BoxSceneObject.compute_pointcloud">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_pointcloud</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pointcloud_samples_per_object</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute pointcloud for box by sampling points on the surface.&quot;&quot;&quot;</span>

        <span class="c1"># TODO: yifeng: we probably should always include the corners, no matter what</span>
        <span class="c1"># Special case: if exactly 8 points requested, return the 8 corners</span>
        <span class="k">if</span> <span class="n">pointcloud_samples_per_object</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
            <span class="c1"># Get the box dimensions</span>
            <span class="c1"># print(&quot;compute_pointcloud: 8 corner points of box requested&quot;)</span>
            <span class="n">object_dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_dimensions</span><span class="p">()</span>
            <span class="n">min_x</span><span class="p">,</span> <span class="n">max_x</span><span class="p">,</span> <span class="n">min_y</span><span class="p">,</span> <span class="n">max_y</span><span class="p">,</span> <span class="n">min_z</span><span class="p">,</span> <span class="n">max_z</span> <span class="o">=</span> <span class="n">object_dims</span>
            
            <span class="c1"># Create the 8 corner points</span>
            <span class="n">corners</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span>
                <span class="p">[</span><span class="n">min_x</span><span class="p">,</span> <span class="n">min_y</span><span class="p">,</span> <span class="n">min_z</span><span class="p">],</span>  <span class="c1"># 0: bottom, back, left</span>
                <span class="p">[</span><span class="n">max_x</span><span class="p">,</span> <span class="n">min_y</span><span class="p">,</span> <span class="n">min_z</span><span class="p">],</span>  <span class="c1"># 1: bottom, back, right</span>
                <span class="p">[</span><span class="n">min_x</span><span class="p">,</span> <span class="n">max_y</span><span class="p">,</span> <span class="n">min_z</span><span class="p">],</span>  <span class="c1"># 2: bottom, front, left</span>
                <span class="p">[</span><span class="n">max_x</span><span class="p">,</span> <span class="n">max_y</span><span class="p">,</span> <span class="n">min_z</span><span class="p">],</span>  <span class="c1"># 3: bottom, front, right</span>
                <span class="p">[</span><span class="n">min_x</span><span class="p">,</span> <span class="n">min_y</span><span class="p">,</span> <span class="n">max_z</span><span class="p">],</span>  <span class="c1"># 4: top, back, left</span>
                <span class="p">[</span><span class="n">max_x</span><span class="p">,</span> <span class="n">min_y</span><span class="p">,</span> <span class="n">max_z</span><span class="p">],</span>  <span class="c1"># 5: top, back, right</span>
                <span class="p">[</span><span class="n">min_x</span><span class="p">,</span> <span class="n">max_y</span><span class="p">,</span> <span class="n">max_z</span><span class="p">],</span>  <span class="c1"># 6: top, front, left</span>
                <span class="p">[</span><span class="n">max_x</span><span class="p">,</span> <span class="n">max_y</span><span class="p">,</span> <span class="n">max_z</span><span class="p">],</span>  <span class="c1"># 7: top, front, right</span>
            <span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
            
            <span class="c1"># Normals for the 8 corners (average of adjacent faces) - approximated</span>
            <span class="c1"># For simplicity, assigning dominant face normal, though true corner normal is ambiguous</span>
            <span class="n">corner_normals</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span>
                <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="c1"># Bottom 4</span>
                <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">],</span> <span class="p">[</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">],</span> <span class="p">[</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">]</span>  <span class="c1"># Top 4</span>
            <span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
            <span class="n">corner_normals</span> <span class="o">=</span> <span class="n">corner_normals</span> <span class="o">/</span> <span class="n">torch</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">corner_normals</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1"># Normalize</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">object_pointcloud</span> <span class="o">=</span> <span class="n">corners</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">object_pointcloud_normals</span> <span class="o">=</span> <span class="n">corner_normals</span>
            <span class="k">return</span>
        
        <span class="c1"># Original implementation for when more than 8 points are requested</span>
        <span class="n">object_dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_dimensions</span><span class="p">()</span>

        <span class="c1"># Calculate surface areas for each face pair</span>
        <span class="n">width</span> <span class="o">=</span> <span class="n">object_dims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">object_dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">depth</span> <span class="o">=</span> <span class="n">object_dims</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">object_dims</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">height</span> <span class="o">=</span> <span class="n">object_dims</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">-</span> <span class="n">object_dims</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>

        <span class="c1"># Calculate area of each face pair (front/back, left/right, top/bottom)</span>
        <span class="n">area_x</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">depth</span> <span class="o">*</span> <span class="n">height</span><span class="p">)</span>  <span class="c1"># front and back faces</span>
        <span class="n">area_y</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">width</span> <span class="o">*</span> <span class="n">height</span><span class="p">)</span>  <span class="c1"># left and right faces</span>
        <span class="n">area_z</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">width</span> <span class="o">*</span> <span class="n">depth</span><span class="p">)</span>  <span class="c1"># top and bottom faces</span>
        <span class="n">total_area</span> <span class="o">=</span> <span class="n">area_x</span> <span class="o">+</span> <span class="n">area_y</span> <span class="o">+</span> <span class="n">area_z</span>

        <span class="c1"># Distribute points according to surface area</span>
        <span class="n">points_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">pointcloud_samples_per_object</span> <span class="o">*</span> <span class="p">(</span><span class="n">area_x</span> <span class="o">/</span> <span class="n">total_area</span><span class="p">))</span>
        <span class="n">points_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">pointcloud_samples_per_object</span> <span class="o">*</span> <span class="p">(</span><span class="n">area_y</span> <span class="o">/</span> <span class="n">total_area</span><span class="p">))</span>
        <span class="n">points_z</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">pointcloud_samples_per_object</span> <span class="o">-</span> <span class="n">points_x</span> <span class="o">-</span> <span class="n">points_y</span>
        <span class="p">)</span>  <span class="c1"># Remaining points</span>

        <span class="c1"># Split points evenly between each pair of faces</span>
        <span class="n">points_front</span> <span class="o">=</span> <span class="n">points_x</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">points_back</span> <span class="o">=</span> <span class="n">points_x</span> <span class="o">-</span> <span class="n">points_front</span>
        <span class="n">points_right</span> <span class="o">=</span> <span class="n">points_y</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">points_left</span> <span class="o">=</span> <span class="n">points_y</span> <span class="o">-</span> <span class="n">points_right</span>
        <span class="n">points_top</span> <span class="o">=</span> <span class="n">points_z</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">points_bottom</span> <span class="o">=</span> <span class="n">points_z</span> <span class="o">-</span> <span class="n">points_top</span>

        <span class="n">faces_points</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">faces_normals</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># List to store normals for each face</span>

        <span class="c1"># Helper function to generate grid points on a face</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">generate_face_points</span><span class="p">(</span><span class="n">num_points</span><span class="p">,</span> <span class="n">fixed_dim</span><span class="p">,</span> <span class="n">fixed_val</span><span class="p">,</span> <span class="n">var_dim1</span><span class="p">,</span> <span class="n">var_dim2</span><span class="p">):</span>
            <span class="c1"># Calculate aspect ratio of the face</span>
            <span class="n">width</span> <span class="o">=</span> <span class="n">var_dim1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">var_dim1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">height</span> <span class="o">=</span> <span class="n">var_dim2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">var_dim2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">aspect_ratio</span> <span class="o">=</span> <span class="n">width</span> <span class="o">/</span> <span class="n">height</span>

            <span class="c1"># Calculate points per side maintaining aspect ratio</span>
            <span class="n">points_height</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">num_points</span> <span class="o">/</span> <span class="n">aspect_ratio</span><span class="p">)))</span>
            <span class="n">points_width</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">points_height</span> <span class="o">*</span> <span class="n">aspect_ratio</span><span class="p">))</span>

            <span class="c1"># Adjust if we&#39;re off from target number of points</span>
            <span class="n">total_points</span> <span class="o">=</span> <span class="n">points_width</span> <span class="o">*</span> <span class="n">points_height</span>
            <span class="k">if</span> <span class="n">total_points</span> <span class="o">&lt;</span> <span class="n">num_points</span><span class="p">:</span>
                <span class="c1"># Add extra points to the longer side</span>
                <span class="k">if</span> <span class="n">width</span> <span class="o">&gt;</span> <span class="n">height</span><span class="p">:</span>
                    <span class="n">points_width</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">points_height</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># Create perfectly even grid</span>
            <span class="n">d1</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">var_dim1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">var_dim1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">points_width</span><span class="p">)</span>
            <span class="n">d2</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">var_dim2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">var_dim2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">points_height</span><span class="p">)</span>

            <span class="c1"># Create meshgrid</span>
            <span class="n">g1</span><span class="p">,</span> <span class="n">g2</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s2">&quot;ij&quot;</span><span class="p">)</span>

            <span class="c1"># Create the points array based on which dimension is fixed</span>
            <span class="k">if</span> <span class="n">fixed_dim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Fixed X</span>
                <span class="n">points</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">torch</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">g1</span><span class="p">,</span> <span class="n">fixed_val</span><span class="p">),</span> <span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="p">],</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">fixed_dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># Fixed Y</span>
                <span class="n">points</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">g1</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">g1</span><span class="p">,</span> <span class="n">fixed_val</span><span class="p">),</span> <span class="n">g2</span><span class="p">],</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># Fixed Z</span>
                <span class="n">points</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">g1</span><span class="p">,</span> <span class="n">fixed_val</span><span class="p">)],</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

            <span class="n">points</span> <span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

            <span class="c1"># If we have more points than needed, take evenly spaced points</span>
            <span class="k">if</span> <span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">num_points</span><span class="p">:</span>
                <span class="n">step</span> <span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="n">num_points</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">step</span><span class="p">)[:</span><span class="n">num_points</span><span class="p">]</span>
                <span class="n">points</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>

            <span class="k">return</span> <span class="n">points</span>

        <span class="c1"># Generate points and normals for each face</span>
        <span class="c1"># Front face (fixed x = max_x), normal = (1, 0, 0)</span>
        <span class="n">front_points</span> <span class="o">=</span> <span class="n">generate_face_points</span><span class="p">(</span><span class="n">points_front</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">object_dims</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="n">object_dims</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">object_dims</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span> <span class="p">(</span><span class="n">object_dims</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">object_dims</span><span class="p">[</span><span class="mi">5</span><span class="p">]))</span>
        <span class="n">faces_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">front_points</span><span class="p">)</span>
        <span class="n">faces_normals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">)</span><span class="o">.</span><span class="n">expand_as</span><span class="p">(</span><span class="n">front_points</span><span class="p">))</span>

        <span class="c1"># Back face (fixed x = min_x), normal = (-1, 0, 0)</span>
        <span class="n">back_points</span> <span class="o">=</span> <span class="n">generate_face_points</span><span class="p">(</span><span class="n">points_back</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">object_dims</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="n">object_dims</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">object_dims</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span> <span class="p">(</span><span class="n">object_dims</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">object_dims</span><span class="p">[</span><span class="mi">5</span><span class="p">]))</span>
        <span class="n">faces_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">back_points</span><span class="p">)</span>
        <span class="n">faces_normals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">)</span><span class="o">.</span><span class="n">expand_as</span><span class="p">(</span><span class="n">back_points</span><span class="p">))</span>

        <span class="c1"># Right face (fixed y = max_y), normal = (0, 1, 0)</span>
        <span class="n">right_points</span> <span class="o">=</span> <span class="n">generate_face_points</span><span class="p">(</span><span class="n">points_right</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">object_dims</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">(</span><span class="n">object_dims</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">object_dims</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="n">object_dims</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">object_dims</span><span class="p">[</span><span class="mi">5</span><span class="p">]))</span>
        <span class="n">faces_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">right_points</span><span class="p">)</span>
        <span class="n">faces_normals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">)</span><span class="o">.</span><span class="n">expand_as</span><span class="p">(</span><span class="n">right_points</span><span class="p">))</span>

        <span class="c1"># Left face (fixed y = min_y), normal = (0, -1, 0)</span>
        <span class="n">left_points</span> <span class="o">=</span> <span class="n">generate_face_points</span><span class="p">(</span><span class="n">points_left</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">object_dims</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="p">(</span><span class="n">object_dims</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">object_dims</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="n">object_dims</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">object_dims</span><span class="p">[</span><span class="mi">5</span><span class="p">]))</span>
        <span class="n">faces_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">left_points</span><span class="p">)</span>
        <span class="n">faces_normals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">)</span><span class="o">.</span><span class="n">expand_as</span><span class="p">(</span><span class="n">left_points</span><span class="p">))</span>

        <span class="c1"># Top face (fixed z = max_z), normal = (0, 0, 1)</span>
        <span class="n">top_points</span> <span class="o">=</span> <span class="n">generate_face_points</span><span class="p">(</span><span class="n">points_top</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">object_dims</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="p">(</span><span class="n">object_dims</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">object_dims</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="n">object_dims</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">object_dims</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>
        <span class="n">faces_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">top_points</span><span class="p">)</span>
        <span class="n">faces_normals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">)</span><span class="o">.</span><span class="n">expand_as</span><span class="p">(</span><span class="n">top_points</span><span class="p">))</span>

        <span class="c1"># Bottom face (fixed z = min_z), normal = (0, 0, -1)</span>
        <span class="n">bottom_points</span> <span class="o">=</span> <span class="n">generate_face_points</span><span class="p">(</span><span class="n">points_bottom</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">object_dims</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="p">(</span><span class="n">object_dims</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">object_dims</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="n">object_dims</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">object_dims</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>
        <span class="n">faces_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bottom_points</span><span class="p">)</span>
        <span class="n">faces_normals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">)</span><span class="o">.</span><span class="n">expand_as</span><span class="p">(</span><span class="n">bottom_points</span><span class="p">))</span>

        <span class="c1"># Combine all face points and normals</span>
        <span class="n">point_cloud</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="n">faces_points</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">point_cloud_normals</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="n">faces_normals</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Final adjustment to match exactly the requested number of points</span>
        <span class="k">if</span> <span class="n">point_cloud</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">pointcloud_samples_per_object</span><span class="p">:</span>
            <span class="c1"># Take evenly spaced points</span>
            <span class="n">step</span> <span class="o">=</span> <span class="n">point_cloud</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="n">pointcloud_samples_per_object</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">point_cloud</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">step</span><span class="p">)[</span>
                <span class="p">:</span><span class="n">pointcloud_samples_per_object</span>
            <span class="p">]</span>
            <span class="n">point_cloud</span> <span class="o">=</span> <span class="n">point_cloud</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
            <span class="n">point_cloud_normals</span> <span class="o">=</span> <span class="n">point_cloud_normals</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span> <span class="c1"># Adjust normals accordingly</span>
        <span class="k">elif</span> <span class="n">point_cloud</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">pointcloud_samples_per_object</span><span class="p">:</span>
            <span class="c1"># Duplicate points evenly from the existing points</span>
            <span class="n">num_repeats</span> <span class="o">=</span> <span class="n">pointcloud_samples_per_object</span> <span class="o">//</span> <span class="n">point_cloud</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">remainder</span> <span class="o">=</span> <span class="n">pointcloud_samples_per_object</span> <span class="o">%</span> <span class="n">point_cloud</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># First, repeat the entire point cloud</span>
            <span class="n">point_cloud</span> <span class="o">=</span> <span class="n">point_cloud</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">num_repeats</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">point_cloud_normals</span> <span class="o">=</span> <span class="n">point_cloud_normals</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">num_repeats</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

            <span class="c1"># Then add the remaining points needed from the beginning</span>
            <span class="k">if</span> <span class="n">remainder</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">extra_points</span> <span class="o">=</span> <span class="n">point_cloud</span><span class="p">[:</span><span class="n">remainder</span><span class="p">]</span>
                <span class="n">extra_normals</span> <span class="o">=</span> <span class="n">point_cloud_normals</span><span class="p">[:</span><span class="n">remainder</span><span class="p">]</span> <span class="c1"># Add corresponding normals</span>
                <span class="n">point_cloud</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">point_cloud</span><span class="p">,</span> <span class="n">extra_points</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">point_cloud_normals</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">point_cloud_normals</span><span class="p">,</span> <span class="n">extra_normals</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># Add corresponding normals</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">object_pointcloud</span> <span class="o">=</span> <span class="n">point_cloud</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">object_pointcloud_normals</span> <span class="o">=</span> <span class="n">point_cloud_normals</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">object_identifier</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate a unique identifier for box shapes&quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">format_float</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;none&quot;</span>
            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;box_w</span><span class="si">{</span><span class="n">format_float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="p">)</span><span class="si">}</span><span class="s2">_d</span><span class="si">{</span><span class="n">format_float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">depth</span><span class="p">)</span><span class="si">}</span><span class="s2">_h</span><span class="si">{</span><span class="n">format_float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">height</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span></div>



<div class="viewcode-block" id="SphereSceneObject">
<a class="viewcode-back" href="../../../api_reference/protomotions.utils.scene_lib.html#protomotions.utils.scene_lib.SphereSceneObject">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">SphereSceneObject</span><span class="p">(</span><span class="n">PrimitiveSceneObject</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Represents a sphere primitive shape.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">radius</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="SphereSceneObject.__post_init__">
<a class="viewcode-back" href="../../../api_reference/protomotions.utils.scene_lib.html#protomotions.utils.scene_lib.SphereSceneObject.__post_init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">__post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Validate dimensions&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Sphere shape requires a radius&quot;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__post_init__</span><span class="p">()</span></div>


<div class="viewcode-block" id="SphereSceneObject.calculate_dimensions">
<a class="viewcode-back" href="../../../api_reference/protomotions.utils.scene_lib.html#protomotions.utils.scene_lib.SphereSceneObject.calculate_dimensions">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate sphere dimensions&quot;&quot;&quot;</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span>
        <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="n">r</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="o">-</span><span class="n">r</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="o">-</span><span class="n">r</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span></div>


<div class="viewcode-block" id="SphereSceneObject.compute_pointcloud">
<a class="viewcode-back" href="../../../api_reference/protomotions.utils.scene_lib.html#protomotions.utils.scene_lib.SphereSceneObject.compute_pointcloud">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_pointcloud</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pointcloud_samples_per_object</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute pointcloud for sphere by sampling points on the surface.&quot;&quot;&quot;</span>
        <span class="c1"># Generate points on unit sphere surface using fibonacci spiral</span>
        <span class="n">golden_ratio</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">5</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">pointcloud_samples_per_object</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">/</span> <span class="n">golden_ratio</span> <span class="o">%</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">cos_theta</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">/</span> <span class="n">pointcloud_samples_per_object</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">cos_theta</span><span class="p">)</span>

        <span class="c1"># Convert spherical coordinates to cartesian</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">cos_theta</span>

        <span class="c1"># Scale by radius and combine into point cloud</span>
        <span class="n">point_cloud</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">object_pointcloud</span> <span class="o">=</span> <span class="n">point_cloud</span>
        <span class="c1"># Normals are the normalized position vectors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">object_pointcloud_normals</span> <span class="o">=</span> <span class="n">point_cloud</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">object_identifier</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate a unique identifier for sphere shapes&quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">format_float</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;none&quot;</span>
            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;sphere_r</span><span class="si">{</span><span class="n">format_float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span></div>



<div class="viewcode-block" id="CylinderSceneObject">
<a class="viewcode-back" href="../../../api_reference/protomotions.utils.scene_lib.html#protomotions.utils.scene_lib.CylinderSceneObject">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">CylinderSceneObject</span><span class="p">(</span><span class="n">PrimitiveSceneObject</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Represents a cylinder primitive shape.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">radius</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">height</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="CylinderSceneObject.__post_init__">
<a class="viewcode-back" href="../../../api_reference/protomotions.utils.scene_lib.html#protomotions.utils.scene_lib.CylinderSceneObject.__post_init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">__post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Validate dimensions&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">height</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cylinder shape requires radius and height dimensions&quot;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__post_init__</span><span class="p">()</span></div>


<div class="viewcode-block" id="CylinderSceneObject.calculate_dimensions">
<a class="viewcode-back" href="../../../api_reference/protomotions.utils.scene_lib.html#protomotions.utils.scene_lib.CylinderSceneObject.calculate_dimensions">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate cylinder dimensions&quot;&quot;&quot;</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span>
        <span class="n">h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">height</span>
        <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="n">r</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="o">-</span><span class="n">r</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="o">-</span><span class="n">h</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">h</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span></div>


<div class="viewcode-block" id="CylinderSceneObject.compute_pointcloud">
<a class="viewcode-back" href="../../../api_reference/protomotions.utils.scene_lib.html#protomotions.utils.scene_lib.CylinderSceneObject.compute_pointcloud">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_pointcloud</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pointcloud_samples_per_object</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute pointcloud for cylinder by sampling points on the surface.&quot;&quot;&quot;</span>
        <span class="c1"># Determine number of points for each part (sides, top, bottom)</span>
        <span class="n">side_points</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">pointcloud_samples_per_object</span> <span class="o">*</span> <span class="mf">0.6</span><span class="p">)</span>  <span class="c1"># 60% for the sides</span>
        
        <span class="c1"># Generate points for the cylindrical surface</span>
        <span class="c1"># Ensure we have at least 2 points for height and theta if side_points &gt; 0</span>
        <span class="n">num_height_points</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">side_points</span><span class="p">)))</span> <span class="k">if</span> <span class="n">side_points</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="n">num_theta_points</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">side_points</span> <span class="o">/</span> <span class="n">num_height_points</span><span class="p">))</span> <span class="k">if</span> <span class="n">num_height_points</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="n">actual_side_points</span> <span class="o">=</span> <span class="n">num_height_points</span> <span class="o">*</span> <span class="n">num_theta_points</span>

        <span class="k">if</span> <span class="n">actual_side_points</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">height</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">num_height_points</span><span class="p">)</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">num_theta_points</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># Avoid duplicate end point</span>
            <span class="n">h</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s2">&quot;ij&quot;</span><span class="p">)</span>
            <span class="n">x_side</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="n">y_side</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="n">z_side</span> <span class="o">=</span> <span class="n">h</span>
            <span class="n">side_points_tensor</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">x_side</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">y_side</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">z_side</span><span class="o">.</span><span class="n">flatten</span><span class="p">()],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># Normals for side surface (x, y, 0) normalized</span>
            <span class="n">side_normals</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">x_side</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">y_side</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">z_side</span><span class="o">.</span><span class="n">flatten</span><span class="p">())],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">side_normals</span> <span class="o">=</span> <span class="n">side_normals</span> <span class="o">/</span> <span class="n">torch</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">side_normals</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">side_points_tensor</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
            <span class="n">side_normals</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>

        <span class="c1"># Adjust cap points based on actual side points generated</span>
        <span class="n">total_generated_points</span> <span class="o">=</span> <span class="n">actual_side_points</span>
        <span class="n">remaining_points</span> <span class="o">=</span> <span class="n">pointcloud_samples_per_object</span> <span class="o">-</span> <span class="n">total_generated_points</span>
        <span class="n">cap_points_each</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">remaining_points</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">top_cap_points_count</span> <span class="o">=</span> <span class="n">cap_points_each</span>
        <span class="n">bottom_cap_points_count</span> <span class="o">=</span> <span class="n">pointcloud_samples_per_object</span> <span class="o">-</span> <span class="n">total_generated_points</span> <span class="o">-</span> <span class="n">top_cap_points_count</span> <span class="c1"># Ensure total count is correct</span>


        <span class="c1"># Generate points for top and bottom caps using spiral pattern</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">generate_cap_points</span><span class="p">(</span><span class="n">z_val</span><span class="p">,</span> <span class="n">num_points</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">num_points</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
            <span class="c1"># Ensure sqrt calculation is safe</span>
            <span class="n">num_sqrt</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">num_points</span><span class="p">)))</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num_sqrt</span><span class="p">))</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">num_sqrt</span><span class="p">)</span> <span class="c1"># Use same number for theta for better grid</span>
            <span class="n">r_grid</span><span class="p">,</span> <span class="n">t_grid</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s2">&quot;ij&quot;</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span> <span class="o">*</span> <span class="n">r_grid</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">t_grid</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span> <span class="o">*</span> <span class="n">r_grid</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t_grid</span><span class="p">)</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">z_val</span><span class="p">)</span>
            <span class="n">cap_points_tensor</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">z</span><span class="o">.</span><span class="n">flatten</span><span class="p">()],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># If we generated more points than needed due to grid, sample randomly</span>
            <span class="k">if</span> <span class="n">cap_points_tensor</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">num_points</span><span class="p">:</span>
                 <span class="n">indices</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randperm</span><span class="p">(</span><span class="n">cap_points_tensor</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])[:</span><span class="n">num_points</span><span class="p">]</span>
                 <span class="n">cap_points_tensor</span> <span class="o">=</span> <span class="n">cap_points_tensor</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">cap_points_tensor</span>

        <span class="n">top_points_tensor</span> <span class="o">=</span> <span class="n">generate_cap_points</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">top_cap_points_count</span><span class="p">)</span>
        <span class="n">bottom_points_tensor</span> <span class="o">=</span> <span class="n">generate_cap_points</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">bottom_cap_points_count</span><span class="p">)</span>

        <span class="c1"># Normals for caps</span>
        <span class="n">top_normals</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">)</span><span class="o">.</span><span class="n">expand_as</span><span class="p">(</span><span class="n">top_points_tensor</span><span class="p">)</span>
        <span class="n">bottom_normals</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">)</span><span class="o">.</span><span class="n">expand_as</span><span class="p">(</span><span class="n">bottom_points_tensor</span><span class="p">)</span>

        <span class="c1"># Combine all points and normals</span>
        <span class="n">point_cloud</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">side_points_tensor</span><span class="p">,</span> <span class="n">top_points_tensor</span><span class="p">,</span> <span class="n">bottom_points_tensor</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">point_cloud_normals</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">side_normals</span><span class="p">,</span> <span class="n">top_normals</span><span class="p">,</span> <span class="n">bottom_normals</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Ensure the exact number of points if somehow undershot (unlikely with adjustments)</span>
        <span class="n">current_points</span> <span class="o">=</span> <span class="n">point_cloud</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">current_points</span> <span class="o">&lt;</span> <span class="n">pointcloud_samples_per_object</span><span class="p">:</span>
             <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Warning: Cylinder point cloud generated </span><span class="si">{</span><span class="n">current_points</span><span class="si">}</span><span class="s2"> points, requested </span><span class="si">{</span><span class="n">pointcloud_samples_per_object</span><span class="si">}</span><span class="s2">. Duplicating points.&quot;</span><span class="p">)</span>
             <span class="n">needed</span> <span class="o">=</span> <span class="n">pointcloud_samples_per_object</span> <span class="o">-</span> <span class="n">current_points</span>
             <span class="n">extra_indices</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">current_points</span><span class="p">,</span> <span class="p">(</span><span class="n">needed</span><span class="p">,))</span>
             <span class="n">point_cloud</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">point_cloud</span><span class="p">,</span> <span class="n">point_cloud</span><span class="p">[</span><span class="n">extra_indices</span><span class="p">]],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
             <span class="n">point_cloud_normals</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">point_cloud_normals</span><span class="p">,</span> <span class="n">point_cloud_normals</span><span class="p">[</span><span class="n">extra_indices</span><span class="p">]],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">object_pointcloud</span> <span class="o">=</span> <span class="n">point_cloud</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">object_pointcloud_normals</span> <span class="o">=</span> <span class="n">point_cloud_normals</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">object_identifier</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate a unique identifier for cylinder shapes&quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">format_float</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;none&quot;</span>
            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;cylinder_r</span><span class="si">{</span><span class="n">format_float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">)</span><span class="si">}</span><span class="s2">_h</span><span class="si">{</span><span class="n">format_float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">height</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span></div>



<div class="viewcode-block" id="Scene">
<a class="viewcode-back" href="../../../api_reference/protomotions.utils.scene_lib.html#protomotions.utils.scene_lib.Scene">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Scene</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Represents a scene consisting of one or more SceneObjects.</span>
<span class="sd">    An offset (x, y) indicates the scene&#39;s location.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">objects</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">SceneObject</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">list</span><span class="p">)</span>
    <span class="n">offset</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>

    <span class="n">humanoid_motion_id</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="p">(</span>
        <span class="o">-</span><span class="mi">1</span>
    <span class="p">)</span>  <span class="c1"># specific human motion to use for this scene, -1 means None</span>

<div class="viewcode-block" id="Scene.add_object">
<a class="viewcode-back" href="../../../api_reference/protomotions.utils.scene_lib.html#protomotions.utils.scene_lib.Scene.add_object">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scene_object</span><span class="p">:</span> <span class="n">SceneObject</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add an object to the scene.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">scene_object</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="ReplicationMethod">
<a class="viewcode-back" href="../../../api_reference/protomotions.utils.scene_lib.html#protomotions.utils.scene_lib.ReplicationMethod">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ReplicationMethod</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Method for replicating scenes.&quot;&quot;&quot;</span>
    <span class="n">FIRST</span> <span class="o">=</span> <span class="s2">&quot;first&quot;</span>
    <span class="n">WEIGHTED</span> <span class="o">=</span> <span class="s2">&quot;weighted&quot;</span>
    <span class="n">RANDOM</span> <span class="o">=</span> <span class="s2">&quot;random&quot;</span>
    <span class="n">SEQUENTIAL</span> <span class="o">=</span> <span class="s2">&quot;sequential&quot;</span>

<div class="viewcode-block" id="ReplicationMethod.from_str">
<a class="viewcode-back" href="../../../api_reference/protomotions.utils.scene_lib.html#protomotions.utils.scene_lib.ReplicationMethod.from_str">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_str</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;ReplicationMethod&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create enum from string, case-insensitive.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">next</span><span class="p">(</span>
                <span class="n">member</span> <span class="k">for</span> <span class="n">member</span> <span class="ow">in</span> <span class="bp">cls</span> 
                <span class="k">if</span> <span class="n">member</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&#39; is not a valid </span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">. &quot;</span>
                           <span class="sa">f</span><span class="s2">&quot;Valid values are: </span><span class="si">{</span><span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">value</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="bp">cls</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="SubsetMethod">
<a class="viewcode-back" href="../../../api_reference/protomotions.utils.scene_lib.html#protomotions.utils.scene_lib.SubsetMethod">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SubsetMethod</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Method for subsetting scenes.&quot;&quot;&quot;</span>
    <span class="n">FIRST</span> <span class="o">=</span> <span class="s2">&quot;first&quot;</span>
    <span class="n">RANDOM</span> <span class="o">=</span> <span class="s2">&quot;random&quot;</span>
    <span class="n">SEQUENTIAL</span> <span class="o">=</span> <span class="s2">&quot;sequential&quot;</span>

<div class="viewcode-block" id="SubsetMethod.from_str">
<a class="viewcode-back" href="../../../api_reference/protomotions.utils.scene_lib.html#protomotions.utils.scene_lib.SubsetMethod.from_str">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_str</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;SubsetMethod&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create enum from string, case-insensitive.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">next</span><span class="p">(</span>
                <span class="n">member</span> <span class="k">for</span> <span class="n">member</span> <span class="ow">in</span> <span class="bp">cls</span> 
                <span class="k">if</span> <span class="n">member</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&#39; is not a valid </span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">. &quot;</span>
                           <span class="sa">f</span><span class="s2">&quot;Valid values are: </span><span class="si">{</span><span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">value</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="bp">cls</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>
</div>


<div class="viewcode-block" id="SceneLibConfig">
<a class="viewcode-back" href="../../../api_reference/protomotions.utils.scene_lib.html#protomotions.utils.scene_lib.SceneLibConfig">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">SceneLibConfig</span><span class="p">(</span><span class="n">ConfigBuilder</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Configuration for scene library - static parameters only.</span>
<span class="sd">    </span>
<span class="sd">    Runtime parameters (num_envs, terrain, scene_weights) are passed to SceneLib constructor.</span>
<span class="sd">    </span>
<span class="sd">    The configuration includes options for loading scenes from files, controlling replication</span>
<span class="sd">    strategies, and setting pointcloud sampling parameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_target_</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;protomotions.utils.scene_lib.SceneLib&quot;</span>
    <span class="n">scene_file</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Renamed from &#39;file&#39;</span>
    <span class="n">subset_method</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">SubsetMethod</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="n">SubsetMethod</span><span class="o">.</span><span class="n">FIRST</span>
    <span class="n">replicate_method</span><span class="p">:</span> <span class="n">ReplicationMethod</span> <span class="o">=</span> <span class="n">ReplicationMethod</span><span class="o">.</span><span class="n">WEIGHTED</span>
    <span class="n">pointcloud_samples_per_object</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">num_objects_per_env</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span></div>



<div class="viewcode-block" id="SceneLib">
<a class="viewcode-back" href="../../../api_reference/protomotions.utils.scene_lib.html#protomotions.utils.scene_lib.SceneLib">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SceneLib</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A scene library for managing object spawning, placement, and motion in simulation environments.</span>

<span class="sd">    SceneLib manages collections of scenes, each containing one or more objects. It handles:</span>
<span class="sd">    - Scene replication/subsetting across environments</span>
<span class="sd">    - Object motion data combination and interpolation</span>
<span class="sd">    - Pointcloud generation for object observations</span>
<span class="sd">    </span>
<span class="sd">    Usage Workflows:</span>
<span class="sd">    </span>
<span class="sd">    1. Programmatic scene creation (tutorials, testing)::</span>
<span class="sd">    </span>
<span class="sd">        config = SceneLibConfig(scene_file=None, replicate_method=&quot;random&quot;)</span>
<span class="sd">        scenes = [Scene(objects=[obj1, obj2]), ...]</span>
<span class="sd">        scene_lib = SceneLib(config, num_envs, scenes, device, terrain)</span>
<span class="sd">    </span>
<span class="sd">    2. Loading from file (production, training)::</span>
<span class="sd">    </span>
<span class="sd">        config = SceneLibConfig(scene_file=&quot;scenes.pt&quot;, replicate_method=&quot;weighted&quot;)</span>
<span class="sd">        scene_lib = SceneLib(config, num_envs, scenes=None, device, terrain, scene_weights)</span>
<span class="sd">    </span>
<span class="sd">    3. Saving scenes for reuse (static method - no SceneLib instance or config needed)::</span>
<span class="sd">    </span>
<span class="sd">        SceneLib.save_scenes_to_file(scenes, &quot;scenes.pt&quot;)</span>
<span class="sd">        </span>
<span class="sd">        # Note: Saved files contain only scene data (objects, poses, motion).</span>
<span class="sd">        # SceneLibConfig parameters (replicate_method, subset_method, etc.) are NOT saved.</span>
<span class="sd">        # Provide a fresh config when loading to specify runtime behavior.</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Key Assumptions:</span>
<span class="sd">    - All scenes must have the same number of objects</span>
<span class="sd">    - Object order within scenes matters (used for indexing)</span>
<span class="sd">    - Scene offsets calculated from terrain layout if terrain provided</span>
<span class="sd">    - Static objects (fix_base_link=True) have single frame, dynamic can have motion</span>
<span class="sd">    - FPS required for objects with motion, defaults to 1.0 for static objects</span>
<span class="sd">    </span>
<span class="sd">    Internal State Tensors:</span>
<span class="sd">    </span>
<span class="sd">    Object Motion Data (combined from ORIGINAL scenes only, like MotionLib):</span>
<span class="sd">        _object_translations: torch.Tensor (total_frames, 3)</span>
<span class="sd">            All object translations from original scenes concatenated</span>
<span class="sd">        _object_rotations: torch.Tensor (total_frames, 4)</span>
<span class="sd">            All object rotations (quaternions xyzw) from original scenes concatenated</span>
<span class="sd">        _motion_lengths: torch.Tensor (num_original_objects,)</span>
<span class="sd">            Motion length in seconds for each original object</span>
<span class="sd">            num_original_objects = len(_original_scenes) * num_objects_per_scene</span>
<span class="sd">        _motion_starts: torch.Tensor (num_original_objects,)</span>
<span class="sd">            Starting frame index in concatenated arrays for each original object</span>
<span class="sd">        _motion_dts: torch.Tensor (num_original_objects,)</span>
<span class="sd">            Delta time (1/fps) per frame for each original object</span>
<span class="sd">        _motion_num_frames: torch.Tensor (num_original_objects,)</span>
<span class="sd">            Number of frames for each original object (1 for static, &gt;1 for dynamic)</span>
<span class="sd">    </span>
<span class="sd">    Object Geometry Data (combined from ORIGINAL scenes only):</span>
<span class="sd">        _object_pointclouds: torch.Tensor (num_original_scenes, num_objects_per_scene, num_points, 3)</span>
<span class="sd">            Neutral (unposed) pointclouds for original objects in local coordinates</span>
<span class="sd">        _object_pointcloud_normals: torch.Tensor (num_original_scenes, num_objects_per_scene, num_points, 3)</span>
<span class="sd">            Surface normals for original objects</span>
<span class="sd">    </span>
<span class="sd">    Scene Organization:</span>
<span class="sd">        _scene_to_original_scene_id: torch.Tensor (num_envs,)</span>
<span class="sd">            Maps each replicated scene index to its original scene index</span>
<span class="sd">            Enables efficient indexing: replicated scenes share original scene data</span>
<span class="sd">        _is_static_object: torch.Tensor (num_original_scenes, objects_per_scene)</span>
<span class="sd">            Boolean mask indicating which objects in original scenes are static</span>
<span class="sd">        _scene_offsets: List[Tuple[float, float]]</span>
<span class="sd">            (x, y) offset for each replicated scene in world coordinates (num_envs entries)</span>
<span class="sd">    </span>
<span class="sd">    Static vs Dynamic Objects:</span>
<span class="sd">        - Static: options.fix_base_link == True, single frame, no motion</span>
<span class="sd">        - Dynamic: options.fix_base_link == False, can have multi-frame motion data</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="SceneLib.__init__">
<a class="viewcode-back" href="../../../api_reference/protomotions.utils.scene_lib.html#protomotions.utils.scene_lib.SceneLib.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">config</span><span class="p">:</span> <span class="s1">&#39;SceneLibConfig&#39;</span><span class="p">,</span> <span class="n">num_envs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">scenes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Scene</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                 <span class="n">device</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;cpu&quot;</span><span class="p">,</span> <span class="n">terrain</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Terrain</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">scene_weights</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize SceneLib from config.</span>
<span class="sd">        </span>
<span class="sd">        Creates either a populated scene library (if config.scene_file is set or scenes provided) or</span>
<span class="sd">        an empty scene library (if config.scene_file is None and no scenes) following Null Object pattern.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            config: SceneLibConfig (always required, scene_file can be None for empty)</span>
<span class="sd">            num_envs: Number of environments (runtime parameter).</span>
<span class="sd">            scenes: List of Scene objects for programmatic creation. Mutually exclusive with config.scene_file.</span>
<span class="sd">            device: Device for torch tensors (runtime parameter).</span>
<span class="sd">            terrain: Optional Terrain object. Can be None for data processing.</span>
<span class="sd">            scene_weights: Optional weights for weighted replication (runtime parameter, e.g., from checkpoints).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">config</span> <span class="o">=</span> <span class="n">config</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">device</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_envs</span> <span class="o">=</span> <span class="n">num_envs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">terrain</span> <span class="o">=</span> <span class="n">terrain</span>
        
        <span class="c1"># Store original scenes (before replication/subsetting)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_original_scenes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Scene</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Processed scenes (after replication/subsetting)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scenes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Scene</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">num_objects_per_scene</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scene_offsets</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Placeholders for aggregated motion data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_object_translations</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_object_rotations</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_object_pointclouds</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_object_pointcloud_normals</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_motion_lengths</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_motion_starts</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_motion_dts</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_motion_num_frames</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Handle empty scene library (Null Object pattern)</span>
        <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">scene_file</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">scenes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Creating empty SceneLib (no scenes)&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_create_empty</span><span class="p">()</span>
            <span class="k">return</span>
        
        <span class="c1"># Validate num_envs when creating non-empty scene library</span>
        <span class="k">if</span> <span class="n">num_envs</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;num_envs must be &gt; 0 when creating non-empty SceneLib, got </span><span class="si">{</span><span class="n">num_envs</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Load from file OR use provided scenes</span>
        <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">scene_file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">scenes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot provide both config.scene_file and scenes parameter&quot;</span><span class="p">)</span>
            <span class="n">scenes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_scenes_from_file</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">scene_file</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Loaded </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">scenes</span><span class="p">)</span><span class="si">}</span><span class="s2"> original scenes from </span><span class="si">{</span><span class="n">config</span><span class="o">.</span><span class="n">scene_file</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="c1"># Validate scene weights match number of scenes</span>
        <span class="k">if</span> <span class="n">scene_weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">scene_weights</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">scenes</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Number of scene_weights (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">scene_weights</span><span class="p">)</span><span class="si">}</span><span class="s2">) must match &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;number of original scenes (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">scenes</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span>
                <span class="p">)</span>
        
        <span class="c1"># Process pointclouds and instance tracking BEFORE deepcopy</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">pointcloud_samples_per_object</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">scene</span> <span class="ow">in</span> <span class="n">scenes</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">scene</span><span class="o">.</span><span class="n">objects</span><span class="p">:</span>
                    <span class="n">obj</span><span class="o">.</span><span class="n">compute_pointcloud</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">pointcloud_samples_per_object</span><span class="p">)</span>
        
        <span class="c1"># Process objects to set is_first_instance flags BEFORE deepcopy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_scene_objects_for_asset_tracking</span><span class="p">(</span><span class="n">scenes</span><span class="p">)</span>
        
        <span class="c1"># Store original scenes AFTER computing pointclouds and setting flags</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_original_scenes</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">scenes</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_create_scenes</span><span class="p">(</span><span class="n">scenes</span><span class="p">,</span> <span class="n">scene_weights</span><span class="p">)</span></div>

    
    <span class="k">def</span><span class="w"> </span><span class="nf">_create_empty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create an empty scene library with no scenes.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_original_scenes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scenes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_objects_per_scene</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scene_offsets</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_static_object</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">bool</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scene_to_original_scene_id</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">long</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        
        <span class="c1"># Empty motion data tensors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_object_translations</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_object_rotations</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_motion_lengths</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_motion_starts</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">long</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_motion_dts</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_motion_num_frames</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">long</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        
        <span class="c1"># Empty pointcloud data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_object_pointclouds</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_object_pointcloud_normals</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
    
<div class="viewcode-block" id="SceneLib.empty">
<a class="viewcode-back" href="../../../api_reference/protomotions.utils.scene_lib.html#protomotions.utils.scene_lib.SceneLib.empty">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">empty</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">num_envs</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">device</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">terrain</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create an empty SceneLib with no scenes.</span>
<span class="sd">        </span>
<span class="sd">        Factory method for creating empty scene libraries in a concise way.</span>
<span class="sd">        Empty scenes don&#39;t need terrain, but can be provided if available.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            num_envs: Number of environments</span>
<span class="sd">            device: PyTorch device</span>
<span class="sd">            terrain: Terrain instance (optional, not needed for empty SceneLib)</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            Empty SceneLib instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">config</span><span class="o">=</span><span class="n">SceneLibConfig</span><span class="p">(</span><span class="n">scene_file</span><span class="o">=</span><span class="kc">None</span><span class="p">),</span> <span class="n">num_envs</span><span class="o">=</span><span class="n">num_envs</span><span class="p">,</span> <span class="n">scenes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">terrain</span><span class="o">=</span><span class="n">terrain</span><span class="p">)</span></div>

    
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_load_scenes_from_file</span><span class="p">(</span><span class="n">file_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">device</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Scene</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Load original scenes from saved SceneLib file.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            file_path: Path to the SceneLib file</span>
<span class="sd">            device: Device for loading (used for map_location)</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            List[Scene]: Original scenes from the file</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">file_path</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;SceneLib file not found: </span><span class="si">{</span><span class="n">file_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="n">loaded_data</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">map_location</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">weights_only</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">SceneLib</span><span class="o">.</span><span class="n">_deserialize_scenes_from_storage_static</span><span class="p">(</span>
            <span class="n">loaded_data</span><span class="p">[</span><span class="s2">&quot;original_scenes&quot;</span><span class="p">]</span>
        <span class="p">)</span>

<div class="viewcode-block" id="SceneLib.get_humanoid_motion_ids">
<a class="viewcode-back" href="../../../api_reference/protomotions.utils.scene_lib.html#protomotions.utils.scene_lib.SceneLib.get_humanoid_motion_ids">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_humanoid_motion_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">humanoid_motion_ids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">scene</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">scenes</span><span class="p">:</span>
            <span class="n">humanoid_motion_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">scene</span><span class="o">.</span><span class="n">humanoid_motion_id</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;humanoid_motion_ids: </span><span class="si">{</span><span class="n">humanoid_motion_ids</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">motion_id</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">motion_id</span> <span class="ow">in</span> <span class="n">humanoid_motion_ids</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="nb">all</span><span class="p">(</span><span class="n">motion_id</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">motion_id</span> <span class="ow">in</span> <span class="n">humanoid_motion_ids</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">humanoid_motion_ids</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Humanoid motion ids must be either all -1 or all valid motion ids&quot;</span>
            <span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_create_scenes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scenes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Scene</span><span class="p">],</span> <span class="n">scene_weights</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create and assign scenes to environments using configurations from the Terrain object.</span>

<span class="sd">        If fewer scenes are provided than num_envs, replicate scenes using the given replicate_method.</span>
<span class="sd">        If more scenes are provided than num_envs, subset scenes using the given subset_method.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            scenes: List of Scene objects to process and assign to environments.</span>
<span class="sd">            scene_weights: Optional weights for weighted replication. If None, uniform weights used.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Clear previous scene data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pointcloud_samples_per_object</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">pointcloud_samples_per_object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scene_offsets</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">assigned_scenes</span> <span class="o">=</span> <span class="n">scenes</span>
        <span class="n">scene_to_original_ids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">scenes</span><span class="p">)))</span>  <span class="c1"># Initially 1:1 mapping</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">assigned_scenes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_envs</span><span class="p">:</span>
            <span class="n">assigned_scenes</span><span class="p">,</span> <span class="n">scene_weights</span><span class="p">,</span> <span class="n">scene_to_original_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subset_scenes</span><span class="p">(</span>
                <span class="n">assigned_scenes</span><span class="p">,</span> <span class="n">scene_weights</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">subset_method</span><span class="p">,</span> <span class="n">scene_to_original_ids</span>
            <span class="p">)</span>

        <span class="c1"># Replicate scenes if needed and track original scene IDs</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">assigned_scenes</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_envs</span><span class="p">:</span>
            <span class="n">assigned_scenes</span><span class="p">,</span> <span class="n">scene_to_original_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replicate_scenes</span><span class="p">(</span>
                <span class="n">assigned_scenes</span><span class="p">,</span> <span class="n">scene_weights</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">replicate_method</span><span class="p">,</span> <span class="n">scene_to_original_ids</span>
            <span class="p">)</span>

        <span class="c1"># Assign scene offsets (with or without terrain validation)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assign_scene_offsets</span><span class="p">(</span><span class="n">assigned_scenes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">terrain</span><span class="p">)</span>

        <span class="c1"># Store mapping from replicated scene index to original scene index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scene_to_original_scene_id</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span>
            <span class="n">scene_to_original_ids</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">long</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span>
        <span class="p">)</span>
        
        <span class="c1"># Build static/dynamic tracking from ORIGINAL scenes for motion/pointcloud lookup</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_build_static_object_mask</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">scenes</span> <span class="o">=</span> <span class="n">assigned_scenes</span>

        <span class="c1"># Combine from original scenes only (like MotionLib)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointcloud_samples_per_object</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">combine_object_pointclouds</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">combine_object_pointcloud_normals</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">combine_object_motions</span><span class="p">()</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">_process_scene_objects_for_asset_tracking</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scenes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Scene</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Process objects to set is_first_instance flags for asset loading.</span>
<span class="sd">        </span>
<span class="sd">        This sets flags on the provided scenes (should be called before deepcopy).</span>
<span class="sd">        The flags are used by simulators to determine which objects need asset loading.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            scenes: Scenes to process (will be modified in-place)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">first_instances</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># Map object identifiers to their first instance IDs</span>
        <span class="n">instance_counter</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">scene_idx</span><span class="p">,</span> <span class="n">scene</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">scenes</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">obj_idx</span><span class="p">,</span> <span class="n">obj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">scene</span><span class="o">.</span><span class="n">objects</span><span class="p">):</span>
                <span class="n">object_identifier</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">object_identifier</span>

                <span class="c1"># Set instance ID</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">instance_id</span> <span class="o">=</span> <span class="n">instance_counter</span>
                <span class="n">instance_counter</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="k">if</span> <span class="n">object_identifier</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">first_instances</span><span class="p">:</span>
                    <span class="c1"># This is the first instance of this object type</span>
                    <span class="n">obj</span><span class="o">.</span><span class="n">is_first_instance</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">obj</span><span class="o">.</span><span class="n">first_instance_id</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">instance_id</span>
                    <span class="n">first_instances</span><span class="p">[</span><span class="n">object_identifier</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">instance_id</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># This is a subsequent instance of an existing object type</span>
                    <span class="n">obj</span><span class="o">.</span><span class="n">is_first_instance</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="n">obj</span><span class="o">.</span><span class="n">first_instance_id</span> <span class="o">=</span> <span class="n">first_instances</span><span class="p">[</span><span class="n">object_identifier</span><span class="p">]</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">_build_static_object_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Build mask for static objects from original scenes.&quot;&quot;&quot;</span>
        <span class="n">objects_per_scene</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_original_scenes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">objects</span><span class="p">)</span>
        <span class="n">num_original_scenes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_original_scenes</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_static_object</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span>
            <span class="p">(</span><span class="n">num_original_scenes</span><span class="p">,</span> <span class="n">objects_per_scene</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">bool</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span>
        <span class="p">)</span>
        
        <span class="k">for</span> <span class="n">scene_idx</span><span class="p">,</span> <span class="n">scene</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_original_scenes</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">obj_idx</span><span class="p">,</span> <span class="n">obj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">scene</span><span class="o">.</span><span class="n">objects</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_is_static_object</span><span class="p">[</span><span class="n">scene_idx</span><span class="p">,</span> <span class="n">obj_idx</span><span class="p">]</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">obj</span><span class="o">.</span><span class="n">has_motion</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_replicate_scenes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">scenes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Scene</span><span class="p">],</span> <span class="n">scene_weights</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">replicate_method</span><span class="p">:</span> <span class="n">ReplicationMethod</span><span class="p">,</span>
        <span class="n">scene_to_original_ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Scene</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Replicate scenes if needed to match num_envs, tracking original scene IDs.&quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Replicating </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_envs</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="n">scenes</span><span class="p">)</span><span class="si">}</span><span class="s2"> scenes with method: </span><span class="si">{</span><span class="n">replicate_method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">num_scenes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">scenes</span><span class="p">)</span>
        <span class="n">replicated_scenes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">scenes</span><span class="p">)</span>
        <span class="n">replicated_ids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">scene_to_original_ids</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">replicate_method</span> <span class="o">==</span> <span class="n">ReplicationMethod</span><span class="o">.</span><span class="n">SEQUENTIAL</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_envs</span> <span class="o">-</span> <span class="n">num_scenes</span><span class="p">):</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">i</span> <span class="o">%</span> <span class="n">num_scenes</span>
                <span class="n">scene</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">replicated_scenes</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
                <span class="n">replicated_scenes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">scene</span><span class="p">)</span>
                <span class="n">replicated_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">replicated_ids</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>  <span class="c1"># Track original ID</span>
        <span class="k">elif</span> <span class="n">replicate_method</span> <span class="ow">in</span> <span class="p">[</span><span class="n">ReplicationMethod</span><span class="o">.</span><span class="n">RANDOM</span><span class="p">,</span> <span class="n">ReplicationMethod</span><span class="o">.</span><span class="n">WEIGHTED</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">replicate_method</span> <span class="o">==</span> <span class="n">ReplicationMethod</span><span class="o">.</span><span class="n">RANDOM</span><span class="p">:</span>
                <span class="n">scene_weights</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_envs</span> <span class="o">-</span> <span class="n">num_scenes</span><span class="p">):</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choices</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">num_scenes</span><span class="p">),</span> <span class="n">weights</span><span class="o">=</span><span class="n">scene_weights</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">scene</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">replicated_scenes</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
                <span class="n">replicated_scenes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">scene</span><span class="p">)</span>
                <span class="n">replicated_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">replicated_ids</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>  <span class="c1"># Track original ID</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Unknown replicate method: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">replicate_method</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Replicate method must be either ReplicationMethod.SEQUENTIAL or ReplicationMethod.RANDOM.&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">replicated_scenes</span><span class="p">,</span> <span class="n">replicated_ids</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">_subset_scenes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scenes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Scene</span><span class="p">],</span> <span class="n">scene_weights</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> 
                      <span class="n">subset_method</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">SubsetMethod</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">scene_to_original_ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Subset scenes if needed to match num_envs, tracking original scene IDs.&quot;&quot;&quot;</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;subset_method: </span><span class="si">{</span><span class="n">subset_method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">subset_method</span> <span class="o">==</span> <span class="n">SubsetMethod</span><span class="o">.</span><span class="n">FIRST</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">scenes</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">num_envs</span><span class="p">],</span> 
                    <span class="n">scene_weights</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">num_envs</span><span class="p">]</span> <span class="k">if</span> <span class="n">scene_weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span> 
                    <span class="n">scene_to_original_ids</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">num_envs</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">subset_method</span> <span class="o">==</span> <span class="n">SubsetMethod</span><span class="o">.</span><span class="n">LAST</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">scenes</span><span class="p">[</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">num_envs</span><span class="p">:],</span> 
                    <span class="n">scene_weights</span><span class="p">[</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">num_envs</span><span class="p">:]</span> <span class="k">if</span> <span class="n">scene_weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span> 
                    <span class="n">scene_to_original_ids</span><span class="p">[</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">num_envs</span><span class="p">:])</span>
        <span class="k">elif</span> <span class="n">subset_method</span> <span class="o">==</span> <span class="n">SubsetMethod</span><span class="o">.</span><span class="n">RANDOM</span><span class="p">:</span>
            <span class="n">scene_indices</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">scenes</span><span class="p">)),</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_envs</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">([</span><span class="n">scenes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">scene_indices</span><span class="p">],</span> 
                    <span class="p">[</span><span class="n">scene_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">scene_indices</span><span class="p">]</span> <span class="k">if</span> <span class="n">scene_weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span> 
                    <span class="p">[</span><span class="n">scene_to_original_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">scene_indices</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">subset_method</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">scene_indices</span> <span class="o">=</span> <span class="n">subset_method</span>
            <span class="k">return</span> <span class="p">([</span><span class="n">scenes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">scene_indices</span><span class="p">],</span> 
                    <span class="p">[</span><span class="n">scene_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">scene_indices</span><span class="p">]</span> <span class="k">if</span> <span class="n">scene_weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span> 
                    <span class="p">[</span><span class="n">scene_to_original_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">scene_indices</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Unknown subset method: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">subset_method</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Subset method must be either SubsetMethod, or a list of scene indices.&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_assign_scene_offsets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scenes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Scene</span><span class="p">],</span> <span class="n">terrain</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Terrain</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assign scene offsets to environments, with optional terrain validation.</span>

<span class="sd">        Args:</span>
<span class="sd">            scenes: List of Scene objects to assign offsets for.</span>
<span class="sd">            terrain: Optional Terrain object for validation and offset calculation.</span>
<span class="sd">                     If None, uses pre-set scene offsets or defaults to (0.0, 0.0).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">scene</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">scenes</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">terrain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Calculate offsets based on terrain layout</span>
                <span class="n">x_offset</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="p">(</span><span class="n">idx</span> <span class="o">%</span> <span class="n">terrain</span><span class="o">.</span><span class="n">num_scenes_per_column</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="o">*</span> <span class="n">terrain</span><span class="o">.</span><span class="n">spacing_between_scenes</span>
                    <span class="o">+</span> <span class="n">terrain</span><span class="o">.</span><span class="n">border</span> <span class="o">*</span> <span class="n">terrain</span><span class="o">.</span><span class="n">horizontal_scale</span>
                <span class="p">)</span>
                <span class="n">y_offset</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">idx</span> <span class="o">//</span> <span class="n">terrain</span><span class="o">.</span><span class="n">num_scenes_per_column</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="p">)</span> <span class="o">*</span> <span class="n">terrain</span><span class="o">.</span><span class="n">spacing_between_scenes</span> <span class="o">+</span> <span class="n">terrain</span><span class="o">.</span><span class="n">scene_y_offset</span>
                <span class="n">scene</span><span class="o">.</span><span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_offset</span><span class="p">,</span> <span class="n">y_offset</span><span class="p">)</span>

                <span class="c1"># Validate with terrain</span>
                <span class="n">scene_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">x_offset</span> <span class="o">/</span> <span class="n">terrain</span><span class="o">.</span><span class="n">horizontal_scale</span><span class="p">)</span>
                <span class="n">scene_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">y_offset</span> <span class="o">/</span> <span class="n">terrain</span><span class="o">.</span><span class="n">horizontal_scale</span><span class="p">)</span>
                <span class="n">locations</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="n">scene_x</span><span class="p">,</span> <span class="n">scene_y</span><span class="p">]],</span> <span class="n">device</span><span class="o">=</span><span class="n">terrain</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
                <span class="k">assert</span> <span class="p">(</span>
                    <span class="n">terrain</span><span class="o">.</span><span class="n">is_valid_spawn_location</span><span class="p">(</span><span class="n">locations</span><span class="p">)</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
                <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Scene </span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s2"> is not a valid spawn location.&quot;</span>
                <span class="n">terrain</span><span class="o">.</span><span class="n">mark_scene_location</span><span class="p">(</span><span class="n">scene_x</span><span class="p">,</span> <span class="n">scene_y</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># No terrain - use pre-set offset or default to (0, 0)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">scene</span><span class="p">,</span> <span class="s1">&#39;offset&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">scene</span><span class="o">.</span><span class="n">offset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">scene</span><span class="o">.</span><span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">_scene_offsets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">scene</span><span class="o">.</span><span class="n">offset</span><span class="p">)</span>

        <span class="c1"># Ensure each scene has the same number of objects</span>
        <span class="n">object_counts</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">scene</span><span class="o">.</span><span class="n">objects</span><span class="p">)</span> <span class="k">for</span> <span class="n">scene</span> <span class="ow">in</span> <span class="n">scenes</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">object_counts</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="s2">&quot;All scenes must have the same number of objects. Found counts: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">object_counts</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Scenes have inconsistent number of objects: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">object_counts</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_objects_per_scene</span> <span class="o">=</span> <span class="n">object_counts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<div class="viewcode-block" id="SceneLib.combine_object_pointclouds">
<a class="viewcode-back" href="../../../api_reference/protomotions.utils.scene_lib.html#protomotions.utils.scene_lib.SceneLib.combine_object_pointclouds">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">combine_object_pointclouds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Combine pointclouds from ORIGINAL scenes only (not replicated).&quot;&quot;&quot;</span>
        <span class="n">all_pointclouds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">scene</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_original_scenes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">scene</span><span class="o">.</span><span class="n">objects</span><span class="p">:</span>
                <span class="n">all_pointclouds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">object_pointcloud</span><span class="p">)</span>
        <span class="n">num_original_scenes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_original_scenes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_object_pointclouds</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="n">all_pointclouds</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">num_original_scenes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_objects_per_scene</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
            <span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="SceneLib.combine_object_pointcloud_normals">
<a class="viewcode-back" href="../../../api_reference/protomotions.utils.scene_lib.html#protomotions.utils.scene_lib.SceneLib.combine_object_pointcloud_normals">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">combine_object_pointcloud_normals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Combine pointcloud normals from ORIGINAL scenes only (not replicated).&quot;&quot;&quot;</span>
        <span class="n">all_normals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">scene</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_original_scenes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">scene</span><span class="o">.</span><span class="n">objects</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">object_pointcloud_normals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                     <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Object </span><span class="si">{</span><span class="n">obj</span><span class="o">.</span><span class="n">instance_id</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">obj</span><span class="o">.</span><span class="n">object_identifier</span><span class="si">}</span><span class="s2">) is missing pointcloud normals.&quot;</span><span class="p">)</span>
                <span class="n">all_normals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">object_pointcloud_normals</span><span class="p">)</span>

        <span class="n">num_original_scenes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_original_scenes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_object_pointcloud_normals</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">all_normals</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># Use stack instead of cat if shapes are guaranteed [N_points, 3]</span>
            <span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">num_original_scenes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_objects_per_scene</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="c1"># Reshape assuming N_points is constant</span>
            <span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="SceneLib.combine_object_motions">
<a class="viewcode-back" href="../../../api_reference/protomotions.utils.scene_lib.html#protomotions.utils.scene_lib.SceneLib.combine_object_motions">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">combine_object_motions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Combine motion data from ORIGINAL SceneObjects into unified tensors.</span>
<span class="sd">        </span>
<span class="sd">        Like MotionLib, this combines data from original scenes only (not replicated).</span>
<span class="sd">        Replicated scenes map to original object indices via _scene_to_original_scene_id.</span>

<span class="sd">        For each SceneObject in original scenes:</span>
<span class="sd">          - If motion is provided (multiple frames), all frames are processed.</span>
<span class="sd">          - Otherwise, a default static frame (using the object&#39;s translation and rotation) is added.</span>

<span class="sd">        The following tensors are created and stored in SceneLib:</span>
<span class="sd">            - self._object_translations: (total_frames, 3) - From original scenes only</span>
<span class="sd">            - self._object_rotations: (total_frames, 4) - From original scenes only</span>
<span class="sd">            - self._motion_lengths: (num_original_objects,) - Length per original object</span>
<span class="sd">            - self._motion_starts: (num_original_objects,) - Starting indices</span>
<span class="sd">            - self._motion_dts: (num_original_objects,) - Delta time per object</span>
<span class="sd">            - self._motion_num_frames: (num_original_objects,) - Frames per object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">all_translations</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># List of tensors to concatenate</span>
        <span class="n">all_rotations</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># List of tensors to concatenate</span>
        <span class="n">motion_lengths_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">motion_dts_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">motion_num_frames_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">motion_starts</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># Map object index -&gt; starting index</span>
        <span class="n">current_start</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Combine from ORIGINAL scenes only (like MotionLib)</span>
        <span class="n">all_objects</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">scene</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_original_scenes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">scene</span><span class="o">.</span><span class="n">objects</span><span class="p">:</span>
                <span class="n">all_objects</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">obj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">all_objects</span><span class="p">):</span>
            <span class="n">motion_starts</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_start</span>

            <span class="n">fps</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">fps</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">fps</span>

            <span class="c1"># Get number of frames</span>
            <span class="n">num_frames</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">translation</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">motion_length</span> <span class="o">=</span> <span class="n">num_frames</span> <span class="o">*</span> <span class="n">dt</span>
            <span class="n">motion_lengths_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">motion_length</span><span class="p">)</span>
            <span class="n">motion_dts_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
            <span class="n">motion_num_frames_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">num_frames</span><span class="p">)</span>

            <span class="c1"># Add all frames at once to our list of tensors</span>
            <span class="n">all_translations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">translation</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">))</span>
            <span class="n">all_rotations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">rotation</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">))</span>

            <span class="n">current_start</span> <span class="o">+=</span> <span class="n">num_frames</span>

        <span class="c1"># Concatenate all the tensors at once</span>
        <span class="k">if</span> <span class="n">all_translations</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_object_translations</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="n">all_translations</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_object_rotations</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="n">all_rotations</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_object_translations</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_object_rotations</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_motion_lengths</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span>
            <span class="n">motion_lengths_list</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span>
        <span class="p">)</span>
        <span class="n">num_objects</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_objects</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_motion_starts</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span>
            <span class="p">[</span><span class="n">motion_starts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_objects</span><span class="p">)],</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">long</span><span class="p">,</span>
            <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_motion_dts</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span>
            <span class="n">motion_dts_list</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_motion_num_frames</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span>
            <span class="n">motion_num_frames_list</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">long</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span>
        <span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Combined motion data for </span><span class="si">%d</span><span class="s2"> objects with total frames: </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">num_objects</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_object_translations</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_calc_frame_blend</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">time</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">length</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">num_frames</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">dt</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate frame indices and blend factor for interpolation.</span>

<span class="sd">        Args:</span>
<span class="sd">            time (torch.Tensor): Current time.</span>
<span class="sd">            length (torch.Tensor): Length of the motion sequence in seconds.</span>
<span class="sd">            num_frames (torch.Tensor): Number of frames in the motion sequence.</span>
<span class="sd">            dt (torch.Tensor): Time step between frames.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple[torch.Tensor, torch.Tensor, torch.Tensor]: Frame index 0, frame index 1, and blend factor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">phase</span> <span class="o">=</span> <span class="n">time</span> <span class="o">/</span> <span class="n">length</span>
        <span class="n">phase</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">phase</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>

        <span class="n">frame_idx0</span> <span class="o">=</span> <span class="p">(</span><span class="n">phase</span> <span class="o">*</span> <span class="p">(</span><span class="n">num_frames</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">long</span><span class="p">()</span>
        <span class="n">frame_idx1</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">frame_idx0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num_frames</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">blend</span> <span class="o">=</span> <span class="p">(</span><span class="n">time</span> <span class="o">-</span> <span class="n">frame_idx0</span> <span class="o">*</span> <span class="n">dt</span><span class="p">)</span> <span class="o">/</span> <span class="n">dt</span>

        <span class="k">return</span> <span class="n">frame_idx0</span><span class="p">,</span> <span class="n">frame_idx1</span><span class="p">,</span> <span class="n">blend</span>

<div class="viewcode-block" id="SceneLib.get_object_pose">
<a class="viewcode-back" href="../../../api_reference/protomotions.utils.scene_lib.html#protomotions.utils.scene_lib.SceneLib.get_object_pose">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_object_pose</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">object_indices</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">time</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ObjectState</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the interpolated poses for multiple objects at given times.</span>

<span class="sd">        Args:</span>
<span class="sd">            object_indices (torch.Tensor): 1D tensor of object indices with length equal to num_envs.</span>
<span class="sd">            time (torch.Tensor): 1D tensor of times at which to interpolate poses, length equal to num_envs.</span>

<span class="sd">        Returns:</span>
<span class="sd">            ObjectState: A batched ObjectState with translations (num_envs, 3) and rotations (num_envs, 4).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_motion_starts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="s2">&quot;Motion data not combined. Call combine_object_motions() first.&quot;</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Motion data not combined.&quot;</span><span class="p">)</span>

        <span class="n">dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_motion_dts</span><span class="p">[</span><span class="n">object_indices</span><span class="p">]</span>
        <span class="n">length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_motion_lengths</span><span class="p">[</span><span class="n">object_indices</span><span class="p">]</span>
        <span class="n">num_frames</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_motion_num_frames</span><span class="p">[</span><span class="n">object_indices</span><span class="p">]</span>
        <span class="n">start_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_motion_starts</span><span class="p">[</span><span class="n">object_indices</span><span class="p">]</span>

        <span class="n">t_tensor</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="n">frame_idx0</span><span class="p">,</span> <span class="n">frame_idx1</span><span class="p">,</span> <span class="n">blend</span> <span class="o">=</span> <span class="n">calc_frame_blend</span><span class="p">(</span>
            <span class="n">t_tensor</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">num_frames</span><span class="p">,</span> <span class="n">dt</span>
        <span class="p">)</span>
        <span class="n">idx0</span> <span class="o">=</span> <span class="n">start_idx</span> <span class="o">+</span> <span class="n">frame_idx0</span>
        <span class="n">idx1</span> <span class="o">=</span> <span class="n">start_idx</span> <span class="o">+</span> <span class="n">frame_idx1</span>

        <span class="n">translation0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_object_translations</span><span class="p">[</span><span class="n">idx0</span><span class="p">]</span>
        <span class="n">translation1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_object_translations</span><span class="p">[</span><span class="n">idx1</span><span class="p">]</span>
        <span class="n">translation</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">blend</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">translation0</span> <span class="o">+</span> <span class="n">blend</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span>
            <span class="o">-</span><span class="mi">1</span>
        <span class="p">)</span> <span class="o">*</span> <span class="n">translation1</span>

        <span class="n">rotation0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_object_rotations</span><span class="p">[</span><span class="n">idx0</span><span class="p">]</span>
        <span class="n">rotation1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_object_rotations</span><span class="p">[</span><span class="n">idx1</span><span class="p">]</span>

        <span class="c1"># Apply slerp to all rotations at once using proper tensor shapes</span>
        <span class="c1"># Add batch dimension to blend for broadcasting</span>
        <span class="n">blend_for_slerp</span> <span class="o">=</span> <span class="n">blend</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Shape: [batch, 1, 1]</span>

        <span class="n">rotation</span> <span class="o">=</span> <span class="n">rotations</span><span class="o">.</span><span class="n">slerp</span><span class="p">(</span>
            <span class="n">rotation0</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">rotation1</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">blend_for_slerp</span>
        <span class="p">)</span>
        <span class="n">rotation</span> <span class="o">=</span> <span class="n">rotation</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Remove the added dimension</span>

        <span class="k">return</span> <span class="n">ObjectState</span><span class="p">(</span><span class="n">root_pos</span><span class="o">=</span><span class="n">translation</span><span class="p">,</span> <span class="n">root_rot</span><span class="o">=</span><span class="n">rotation</span><span class="p">,</span> <span class="n">state_conversion</span><span class="o">=</span><span class="n">StateConversion</span><span class="o">.</span><span class="n">COMMON</span><span class="p">)</span></div>


<div class="viewcode-block" id="SceneLib.get_scene_pose">
<a class="viewcode-back" href="../../../api_reference/protomotions.utils.scene_lib.html#protomotions.utils.scene_lib.SceneLib.get_scene_pose">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_scene_pose</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">scene_indices</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">time</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">respawn_offset</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ObjectState</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the interpolated poses for all objects in the specified scenes at given times.</span>

<span class="sd">        Args:</span>
<span class="sd">            scene_indices (torch.Tensor): 1D tensor of scene indices (can be replicated scenes).</span>
<span class="sd">            time (torch.Tensor): 1D tensor of times at which to interpolate poses, should match length of scene_indices.</span>
<span class="sd">            respawn_offset (float): Z-offset to apply to non-static objects.</span>

<span class="sd">        Returns:</span>
<span class="sd">            ObjectState: An ObjectState with tensors of shape:</span>
<span class="sd">                - translations: [num_scenes, objects_per_scene, 3]</span>
<span class="sd">                - rotations: [num_scenes, objects_per_scene, 4]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Handle empty scene library</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_scenes</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">num_scenes</span> <span class="o">=</span> <span class="n">scene_indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">scene_indices</span><span class="o">.</span><span class="n">numel</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="k">return</span> <span class="n">ObjectState</span><span class="p">(</span>
                <span class="n">root_pos</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_scenes</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">),</span>
                <span class="n">root_rot</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_scenes</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">),</span>
                <span class="n">root_vel</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_scenes</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">),</span>
                <span class="n">root_ang_vel</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_scenes</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">),</span>
                <span class="n">state_conversion</span><span class="o">=</span><span class="n">StateConversion</span><span class="o">.</span><span class="n">COMMON</span><span class="p">,</span>
            <span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_motion_starts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="s2">&quot;Motion data not combined. Call combine_object_motions() first.&quot;</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Motion data not combined.&quot;</span><span class="p">)</span>

        <span class="n">num_scenes</span> <span class="o">=</span> <span class="n">scene_indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">objects_per_scene</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_objects_per_scene</span>

        <span class="c1"># Map scene indices to original scene indices</span>
        <span class="n">original_scene_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scene_to_original_scene_id</span><span class="p">[</span><span class="n">scene_indices</span><span class="p">]</span>
        
        <span class="c1"># Calculate object indices in the original (combined) data</span>
        <span class="c1"># Shape: [num_scenes, objects_per_scene]</span>
        <span class="n">batch_object_indices</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">original_scene_indices</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_objects_per_scene</span> <span class="o">+</span> 
            <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_objects_per_scene</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Reshape to a flat tensor - shape: [num_scenes * objects_per_scene]</span>
        <span class="n">batch_object_indices</span> <span class="o">=</span> <span class="n">batch_object_indices</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Repeat each time value for each object in the scene - shape: [num_scenes * objects_per_scene]</span>
        <span class="n">batch_times</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">repeat_interleave</span><span class="p">(</span><span class="n">objects_per_scene</span><span class="p">)</span>

        <span class="c1"># Get poses for all objects in one batch operation</span>
        <span class="n">batch_poses</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_object_pose</span><span class="p">(</span><span class="n">batch_object_indices</span><span class="p">,</span> <span class="n">batch_times</span><span class="p">)</span>

        <span class="c1"># Reshape the results to [num_scenes, objects_per_scene, 3] and [num_scenes, objects_per_scene, 4]</span>
        <span class="n">all_translations</span> <span class="o">=</span> <span class="n">batch_poses</span><span class="o">.</span><span class="n">root_pos</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="n">num_scenes</span><span class="p">,</span> <span class="n">objects_per_scene</span><span class="p">,</span> <span class="mi">3</span>
        <span class="p">)</span>
        <span class="c1"># Get static mask from original scenes</span>
        <span class="n">static_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_static_object</span><span class="p">[</span><span class="n">original_scene_indices</span><span class="p">]</span>

        <span class="c1"># Create an offset matrix and apply it only to non-static objects</span>
        <span class="n">offset_matrix</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">all_translations</span><span class="p">)</span>
        <span class="n">offset_matrix</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">respawn_offset</span>  <span class="c1"># Set z-coordinate to respawn_offset</span>

        <span class="c1"># Apply the mask to only affect non-static objects (expand mask to match dimensions)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="o">~</span><span class="n">static_mask</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">expand_as</span><span class="p">(</span><span class="n">offset_matrix</span><span class="p">)</span>
        <span class="n">offset_matrix</span> <span class="o">=</span> <span class="n">offset_matrix</span> <span class="o">*</span> <span class="n">mask</span>

        <span class="c1"># Add the offset</span>
        <span class="n">all_translations</span> <span class="o">=</span> <span class="n">all_translations</span> <span class="o">+</span> <span class="n">offset_matrix</span>

        <span class="n">all_rotations</span> <span class="o">=</span> <span class="n">batch_poses</span><span class="o">.</span><span class="n">root_rot</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">num_scenes</span><span class="p">,</span> <span class="n">objects_per_scene</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ObjectState</span><span class="p">(</span><span class="n">root_pos</span><span class="o">=</span><span class="n">all_translations</span><span class="p">,</span> <span class="n">root_rot</span><span class="o">=</span><span class="n">all_rotations</span><span class="p">,</span> <span class="n">state_conversion</span><span class="o">=</span><span class="n">StateConversion</span><span class="o">.</span><span class="n">COMMON</span><span class="p">)</span></div>


<div class="viewcode-block" id="SceneLib.get_scene_neutral_pointcloud">
<a class="viewcode-back" href="../../../api_reference/protomotions.utils.scene_lib.html#protomotions.utils.scene_lib.SceneLib.get_scene_neutral_pointcloud">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_scene_neutral_pointcloud</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">scene_indices</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the neutral pointcloud for all objects in the specified scenes.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            scene_indices: Scene indices (can be replicated). If None, returns all original scenes.</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: Pointclouds for the specified scenes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_object_pointclouds&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_object_pointclouds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="s2">&quot;object_pointclouds not initialized. Make sure combine_object_pointclouds was called.&quot;</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Scene object pointclouds not initialized.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">scene_indices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_object_pointclouds</span>
        
        <span class="c1"># Map to original scene indices</span>
        <span class="n">original_scene_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scene_to_original_scene_id</span><span class="p">[</span><span class="n">scene_indices</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_object_pointclouds</span><span class="p">[</span><span class="n">original_scene_indices</span><span class="p">]</span></div>


<div class="viewcode-block" id="SceneLib.get_scene_neutral_pointcloud_normals">
<a class="viewcode-back" href="../../../api_reference/protomotions.utils.scene_lib.html#protomotions.utils.scene_lib.SceneLib.get_scene_neutral_pointcloud_normals">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_scene_neutral_pointcloud_normals</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">scene_indices</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the neutral pointcloud normals for all objects in the specified scenes.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            scene_indices: Scene indices (can be replicated). If None, returns all original scenes.</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: Pointcloud normals for the specified scenes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_object_pointcloud_normals&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_object_pointcloud_normals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="s2">&quot;object_pointcloud_normals not initialized. Make sure create_scenes was called and pointcloud generation was enabled.&quot;</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Scene object pointcloud normals not initialized.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">scene_indices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_object_pointcloud_normals</span>
        
        <span class="c1"># Map to original scene indices</span>
        <span class="n">original_scene_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scene_to_original_scene_id</span><span class="p">[</span><span class="n">scene_indices</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_object_pointcloud_normals</span><span class="p">[</span><span class="n">original_scene_indices</span><span class="p">]</span></div>


<div class="viewcode-block" id="SceneLib.num_scenes">
<a class="viewcode-back" href="../../../api_reference/protomotions.utils.scene_lib.html#protomotions.utils.scene_lib.SceneLib.num_scenes">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">num_scenes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of scenes in the library.</span>

<span class="sd">        This is the number of actual Scene objects AFTER replication</span>
<span class="sd">        Also equals num_envs with current system assumption (one scene assigned per environment)</span>
<span class="sd">        But originally there might be only 5 unique scenes that get replicated to 1000 envs,</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scenes</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">scene_offsets</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the list of scene offsets.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scene_offsets</span>
    
<div class="viewcode-block" id="SceneLib.get_scene_positions">
<a class="viewcode-back" href="../../../api_reference/protomotions.utils.scene_lib.html#protomotions.utils.scene_lib.SceneLib.get_scene_positions">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_scene_positions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">terrain</span><span class="p">:</span> <span class="n">Terrain</span><span class="p">,</span> <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate scene positions in the object playground.</span>
<span class="sd">        </span>
<span class="sd">        Scenes are always placed in the object playground region of the terrain (ref terrain.py),</span>
<span class="sd">        which is always flat at z=0. This returns the [x, y, 0.0] position for each scene.</span>
<span class="sd">        </span>
<span class="sd">        Note: The object playground is a dedicated flat region appended to the terrain grid</span>
<span class="sd">        specifically for scene placement. It is not affected by terrain generation and</span>
<span class="sd">        always remains at ground level (z=0).</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            terrain: Terrain object (not used for height since playground is always flat)</span>
<span class="sd">            device: Device for tensor creation. If None, uses self.device</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            torch.Tensor: Scene positions with shape (num_envs, 3) containing [x, y, 0.0]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">device</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span>
        
        <span class="c1"># Handle empty scene library</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_scenes</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_envs</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        
        <span class="c1"># Stack all scene offsets (x, y) and append z=0 (object playground is always flat)</span>
        <span class="n">scene_xy</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_scene_offsets</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="n">scene_z</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_envs</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">scene_xy</span><span class="p">,</span> <span class="n">scene_z</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>

    
    <span class="c1"># def get_object_dims_tensor(self, device: Optional[str] = None) -&gt; torch.Tensor:</span>
    <span class="c1">#     &quot;&quot;&quot;Get object dimensions as a batched tensor for all environments.</span>
        
    <span class="c1">#     Returns dimensions for all objects mapped through scene replication.</span>
    <span class="c1">#     Each object has 6 dimensions: [min_x, max_x, min_y, max_y, min_z, max_z]</span>
        
    <span class="c1">#     Args:</span>
    <span class="c1">#         device: Device for tensor creation. If None, uses self.device</span>
            
    <span class="c1">#     Returns:</span>
    <span class="c1">#         torch.Tensor: Object dimensions with shape (num_envs, num_objects_per_scene, 6)</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     if device is None:</span>
    <span class="c1">#         device = self.device</span>
        
    <span class="c1">#     # Get dims from original scenes</span>
    <span class="c1">#     original_dims = []</span>
    <span class="c1">#     for scene in self._original_scenes:</span>
    <span class="c1">#         scene_dims = []</span>
    <span class="c1">#         for obj in scene.objects:</span>
    <span class="c1">#             dims = torch.tensor(obj.object_dims, dtype=torch.float, device=device)</span>
    <span class="c1">#             scene_dims.append(dims)</span>
    <span class="c1">#         original_dims.append(torch.stack(scene_dims))</span>
        
    <span class="c1">#     original_dims = torch.stack(original_dims)  # (num_original_scenes, objects_per_scene, 6)</span>
        
    <span class="c1">#     # Map to replicated scenes</span>
    <span class="c1">#     return original_dims[self._scene_to_original_scene_id]  # (num_envs, objects_per_scene, 6)</span>
    
<div class="viewcode-block" id="SceneLib.get_default_object_state">
<a class="viewcode-back" href="../../../api_reference/protomotions.utils.scene_lib.html#protomotions.utils.scene_lib.SceneLib.get_default_object_state">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_default_object_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ObjectState</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get default object state for environment resets.</span>
<span class="sd">        </span>
<span class="sd">        Computes initial poses using get_scene_pose() at time=0</span>
<span class="sd">        </span>
<span class="sd">        For empty SceneLib (no scenes), returns ObjectState with empty tensors.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            device: Device for tensor creation. If None, uses self.device</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            ObjectState: Default object state with:</span>
<span class="sd">                - root_pos: (num_envs, num_objects_per_scene, 3) - Global positions</span>
<span class="sd">                - root_rot: (num_envs, num_objects_per_scene, 4) - Quaternions</span>
<span class="sd">                - root_vel: (num_envs, num_objects_per_scene, 3) - Zeros</span>
<span class="sd">                - root_ang_vel: (num_envs, num_objects_per_scene, 3) - Zeros</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">device</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span>
        
        <span class="c1"># Get all scene indices</span>
        <span class="n">all_scene_indices</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_envs</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
        
        <span class="c1"># Get poses at time=0 (initial poses from motion data)</span>
        <span class="c1"># This handles empty scenes internally</span>
        <span class="n">object_states</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_scene_pose</span><span class="p">(</span>
            <span class="n">scene_indices</span><span class="o">=</span><span class="n">all_scene_indices</span><span class="p">,</span>
            <span class="n">time</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_envs</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">),</span>
            <span class="n">respawn_offset</span><span class="o">=</span><span class="mf">0.0</span>
        <span class="p">)</span>
        
        <span class="c1"># Initialize velocities to zero (already correct shape from get_scene_pose)</span>
        <span class="n">object_states</span><span class="o">.</span><span class="n">root_vel</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">object_states</span><span class="o">.</span><span class="n">root_pos</span><span class="p">)</span>
        <span class="n">object_states</span><span class="o">.</span><span class="n">root_ang_vel</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">object_states</span><span class="o">.</span><span class="n">root_pos</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">object_states</span></div>

    
<div class="viewcode-block" id="SceneLib.save_scenes_to_file">
<a class="viewcode-back" href="../../../api_reference/protomotions.utils.scene_lib.html#protomotions.utils.scene_lib.SceneLib.save_scenes_to_file">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">save_scenes_to_file</span><span class="p">(</span><span class="n">scenes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Scene</span><span class="p">],</span> <span class="n">file_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Save scenes to file without creating a SceneLib instance.</span>
<span class="sd">        </span>
<span class="sd">        This is a convenience static method for saving scenes that were created </span>
<span class="sd">        programmatically. No SceneLib instance or config is needed - just pass </span>
<span class="sd">        the scenes directly.</span>
<span class="sd">        </span>
<span class="sd">        The saved file contains only scene data (objects, poses, motion) and is </span>
<span class="sd">        independent of any SceneLibConfig parameters. When loading, you provide </span>
<span class="sd">        a fresh config with desired runtime parameters (num_envs, replicate_method, etc.).</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            scenes: List of Scene objects to save</span>
<span class="sd">            file_path: Path to save the scenes file (.pt)</span>
<span class="sd">            </span>
<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If scenes have inconsistent number of objects</span>
<span class="sd">            AssertionError: If file_path doesn&#39;t end with .pt</span>
<span class="sd">            </span>
<span class="sd">        Example:</span>
<span class="sd">            ```python</span>
<span class="sd">            scenes = [Scene(objects=[obj1, obj2]), ...]</span>
<span class="sd">            SceneLib.save_scenes_to_file(scenes, &quot;my_scenes.pt&quot;)</span>
<span class="sd">            ```</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">file_path</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.pt&quot;</span><span class="p">),</span> <span class="s2">&quot;File path must end with .pt&quot;</span>
        
        <span class="c1"># Validate all scenes have same number of objects</span>
        <span class="n">object_counts</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">scene</span><span class="o">.</span><span class="n">objects</span><span class="p">)</span> <span class="k">for</span> <span class="n">scene</span> <span class="ow">in</span> <span class="n">scenes</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">object_counts</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;All scenes must have the same number of objects. Found counts: </span><span class="si">{</span><span class="nb">set</span><span class="p">(</span><span class="n">object_counts</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        
        <span class="n">save_data</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;original_scenes&quot;</span><span class="p">:</span> <span class="n">SceneLib</span><span class="o">.</span><span class="n">_serialize_scenes_for_storage_static</span><span class="p">(</span><span class="n">scenes</span><span class="p">),</span>
            <span class="s2">&quot;num_original_scenes&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">scenes</span><span class="p">),</span>
            <span class="s2">&quot;num_objects_per_scene&quot;</span><span class="p">:</span> <span class="n">object_counts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="p">}</span>
        
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span> <span class="ow">or</span> <span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">save_data</span><span class="p">,</span> <span class="n">file_path</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Saved </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">scenes</span><span class="p">)</span><span class="si">}</span><span class="s2"> scenes to </span><span class="si">{</span><span class="n">file_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>

    
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_serialize_scenes_for_storage_static</span><span class="p">(</span><span class="n">scenes_to_serialize</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Scene</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Serialize scenes to a format suitable for storage (static method).</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            scenes_to_serialize: List of scenes to serialize.</span>
<span class="sd">        &quot;&quot;&quot;</span>
            
        <span class="n">serialized_scenes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">scene</span> <span class="ow">in</span> <span class="n">scenes_to_serialize</span><span class="p">:</span>
            <span class="n">scene_data</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;offset&quot;</span><span class="p">:</span> <span class="n">scene</span><span class="o">.</span><span class="n">offset</span><span class="p">,</span>
                <span class="s2">&quot;humanoid_motion_id&quot;</span><span class="p">:</span> <span class="n">scene</span><span class="o">.</span><span class="n">humanoid_motion_id</span><span class="p">,</span>
                <span class="s2">&quot;objects&quot;</span><span class="p">:</span> <span class="p">[]</span>
            <span class="p">}</span>
            <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">scene</span><span class="o">.</span><span class="n">objects</span><span class="p">:</span>
                <span class="n">obj_data</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                    <span class="s2">&quot;translation&quot;</span><span class="p">:</span> <span class="n">obj</span><span class="o">.</span><span class="n">translation</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
                    <span class="s2">&quot;rotation&quot;</span><span class="p">:</span> <span class="n">obj</span><span class="o">.</span><span class="n">rotation</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
                    <span class="s2">&quot;fps&quot;</span><span class="p">:</span> <span class="n">obj</span><span class="o">.</span><span class="n">fps</span><span class="p">,</span>
                    <span class="s2">&quot;object_dims&quot;</span><span class="p">:</span> <span class="n">obj</span><span class="o">.</span><span class="n">object_dims</span><span class="p">,</span>
                    <span class="s2">&quot;options&quot;</span><span class="p">:</span> <span class="p">{</span>
                        <span class="n">field_name</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">options</span><span class="p">,</span> <span class="n">field_name</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">field_name</span> <span class="ow">in</span> <span class="n">obj</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="vm">__dict__</span>
                        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">options</span><span class="p">,</span> <span class="n">field_name</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                    <span class="p">}</span>
                <span class="p">}</span>
                <span class="c1"># Type-specific properties</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">BoxSceneObject</span><span class="p">):</span>
                    <span class="n">obj_data</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;width&quot;</span><span class="p">:</span> <span class="n">obj</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="s2">&quot;depth&quot;</span><span class="p">:</span> <span class="n">obj</span><span class="o">.</span><span class="n">depth</span><span class="p">,</span> <span class="s2">&quot;height&quot;</span><span class="p">:</span> <span class="n">obj</span><span class="o">.</span><span class="n">height</span><span class="p">})</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">SphereSceneObject</span><span class="p">):</span>
                    <span class="n">obj_data</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;radius&quot;</span><span class="p">:</span> <span class="n">obj</span><span class="o">.</span><span class="n">radius</span><span class="p">})</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">CylinderSceneObject</span><span class="p">):</span>
                    <span class="n">obj_data</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;radius&quot;</span><span class="p">:</span> <span class="n">obj</span><span class="o">.</span><span class="n">radius</span><span class="p">,</span> <span class="s2">&quot;height&quot;</span><span class="p">:</span> <span class="n">obj</span><span class="o">.</span><span class="n">height</span><span class="p">})</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">MeshSceneObject</span><span class="p">):</span>
                    <span class="n">obj_data</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;object_path&quot;</span><span class="p">:</span> <span class="n">obj</span><span class="o">.</span><span class="n">object_path</span><span class="p">})</span>
                <span class="n">scene_data</span><span class="p">[</span><span class="s2">&quot;objects&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj_data</span><span class="p">)</span>
            <span class="n">serialized_scenes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">scene_data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">serialized_scenes</span>
    
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_deserialize_scenes_from_storage_static</span><span class="p">(</span><span class="n">serialized_scenes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Scene</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Static method to deserialize scenes from storage format.&quot;&quot;&quot;</span>
        <span class="n">scenes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">scene_data</span> <span class="ow">in</span> <span class="n">serialized_scenes</span><span class="p">:</span>
            <span class="n">objects</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">obj_data</span> <span class="ow">in</span> <span class="n">scene_data</span><span class="p">[</span><span class="s2">&quot;objects&quot;</span><span class="p">]:</span>
                <span class="n">options</span> <span class="o">=</span> <span class="n">ObjectOptions</span><span class="p">(</span><span class="o">**</span><span class="n">obj_data</span><span class="p">[</span><span class="s2">&quot;options&quot;</span><span class="p">])</span>
                <span class="n">obj_type</span> <span class="o">=</span> <span class="n">obj_data</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span>
                
                <span class="n">translation</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">obj_data</span><span class="p">[</span><span class="s2">&quot;translation&quot;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
                <span class="n">rotation</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">obj_data</span><span class="p">[</span><span class="s2">&quot;rotation&quot;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
                
                <span class="k">if</span> <span class="n">obj_type</span> <span class="o">==</span> <span class="s2">&quot;BoxSceneObject&quot;</span><span class="p">:</span>
                    <span class="n">obj</span> <span class="o">=</span> <span class="n">BoxSceneObject</span><span class="p">(</span>
                        <span class="n">width</span><span class="o">=</span><span class="n">obj_data</span><span class="p">[</span><span class="s2">&quot;width&quot;</span><span class="p">],</span>
                        <span class="n">depth</span><span class="o">=</span><span class="n">obj_data</span><span class="p">[</span><span class="s2">&quot;depth&quot;</span><span class="p">],</span>
                        <span class="n">height</span><span class="o">=</span><span class="n">obj_data</span><span class="p">[</span><span class="s2">&quot;height&quot;</span><span class="p">],</span>
                        <span class="n">translation</span><span class="o">=</span><span class="n">translation</span><span class="p">,</span>
                        <span class="n">rotation</span><span class="o">=</span><span class="n">rotation</span><span class="p">,</span>
                        <span class="n">fps</span><span class="o">=</span><span class="n">obj_data</span><span class="p">[</span><span class="s2">&quot;fps&quot;</span><span class="p">],</span>
                        <span class="n">options</span><span class="o">=</span><span class="n">options</span>
                    <span class="p">)</span>
                <span class="k">elif</span> <span class="n">obj_type</span> <span class="o">==</span> <span class="s2">&quot;SphereSceneObject&quot;</span><span class="p">:</span>
                    <span class="n">obj</span> <span class="o">=</span> <span class="n">SphereSceneObject</span><span class="p">(</span>
                        <span class="n">radius</span><span class="o">=</span><span class="n">obj_data</span><span class="p">[</span><span class="s2">&quot;radius&quot;</span><span class="p">],</span>
                        <span class="n">translation</span><span class="o">=</span><span class="n">translation</span><span class="p">,</span>
                        <span class="n">rotation</span><span class="o">=</span><span class="n">rotation</span><span class="p">,</span>
                        <span class="n">fps</span><span class="o">=</span><span class="n">obj_data</span><span class="p">[</span><span class="s2">&quot;fps&quot;</span><span class="p">],</span>
                        <span class="n">options</span><span class="o">=</span><span class="n">options</span>
                    <span class="p">)</span>
                <span class="k">elif</span> <span class="n">obj_type</span> <span class="o">==</span> <span class="s2">&quot;CylinderSceneObject&quot;</span><span class="p">:</span>
                    <span class="n">obj</span> <span class="o">=</span> <span class="n">CylinderSceneObject</span><span class="p">(</span>
                        <span class="n">radius</span><span class="o">=</span><span class="n">obj_data</span><span class="p">[</span><span class="s2">&quot;radius&quot;</span><span class="p">],</span>
                        <span class="n">height</span><span class="o">=</span><span class="n">obj_data</span><span class="p">[</span><span class="s2">&quot;height&quot;</span><span class="p">],</span>
                        <span class="n">translation</span><span class="o">=</span><span class="n">translation</span><span class="p">,</span>
                        <span class="n">rotation</span><span class="o">=</span><span class="n">rotation</span><span class="p">,</span>
                        <span class="n">fps</span><span class="o">=</span><span class="n">obj_data</span><span class="p">[</span><span class="s2">&quot;fps&quot;</span><span class="p">],</span>
                        <span class="n">options</span><span class="o">=</span><span class="n">options</span>
                    <span class="p">)</span>
                <span class="k">elif</span> <span class="n">obj_type</span> <span class="o">==</span> <span class="s2">&quot;MeshSceneObject&quot;</span><span class="p">:</span>
                    <span class="n">obj</span> <span class="o">=</span> <span class="n">MeshSceneObject</span><span class="p">(</span>
                        <span class="n">object_path</span><span class="o">=</span><span class="n">obj_data</span><span class="p">[</span><span class="s2">&quot;object_path&quot;</span><span class="p">],</span>
                        <span class="n">translation</span><span class="o">=</span><span class="n">translation</span><span class="p">,</span>
                        <span class="n">rotation</span><span class="o">=</span><span class="n">rotation</span><span class="p">,</span>
                        <span class="n">fps</span><span class="o">=</span><span class="n">obj_data</span><span class="p">[</span><span class="s2">&quot;fps&quot;</span><span class="p">],</span>
                        <span class="n">options</span><span class="o">=</span><span class="n">options</span>
                    <span class="p">)</span>
                
                <span class="n">objects</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
            
            <span class="n">scene</span> <span class="o">=</span> <span class="n">Scene</span><span class="p">(</span>
                <span class="n">objects</span><span class="o">=</span><span class="n">objects</span><span class="p">,</span>
                <span class="n">offset</span><span class="o">=</span><span class="n">scene_data</span><span class="p">[</span><span class="s2">&quot;offset&quot;</span><span class="p">],</span>
                <span class="n">humanoid_motion_id</span><span class="o">=</span><span class="n">scene_data</span><span class="p">[</span><span class="s2">&quot;humanoid_motion_id&quot;</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">scenes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">scene</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">scenes</span></div>



<span class="c1"># ----------------------------------------------------------------------------</span>
<span class="c1"># Example usage:</span>
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>

    <span class="c1"># Define a dummy Terrain for example usage</span>
    <span class="k">class</span><span class="w"> </span><span class="nc">DummyTerrain</span><span class="p">:</span>
        <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_scenes_per_column</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spacing_between_scenes</span> <span class="o">=</span> <span class="mf">5.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">border</span> <span class="o">=</span> <span class="mf">2.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">horizontal_scale</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scene_y_offset</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="s2">&quot;cpu&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">is_valid_spawn_location</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">locations</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">mark_scene_location</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
            <span class="k">pass</span>
    
    <span class="n">terrain</span> <span class="o">=</span> <span class="n">DummyTerrain</span><span class="p">()</span>

    <span class="c1"># Create SceneObjects with options</span>
    <span class="n">obj1</span> <span class="o">=</span> <span class="n">MeshSceneObject</span><span class="p">(</span>
        <span class="n">object_path</span><span class="o">=</span><span class="s2">&quot;examples/data/armchair.obj&quot;</span><span class="p">,</span>
        <span class="n">translation</span><span class="o">=</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
        <span class="n">rotation</span><span class="o">=</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span>
        <span class="c1"># fps will default to 1.0 for static object</span>
        <span class="n">options</span><span class="o">=</span><span class="n">ObjectOptions</span><span class="p">(</span>
            <span class="n">vhacd_enabled</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">vhacd_params</span><span class="o">=</span><span class="p">{</span>
                <span class="s2">&quot;resolution&quot;</span><span class="p">:</span> <span class="mi">50000</span><span class="p">,</span>
                <span class="s2">&quot;max_convex_hulls&quot;</span><span class="p">:</span> <span class="mi">128</span><span class="p">,</span>
                <span class="s2">&quot;max_num_vertices_per_ch&quot;</span><span class="p">:</span> <span class="mi">64</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="n">fix_base_link</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">),</span>
    <span class="p">)</span>

    <span class="c1"># After initialization, obj1.translation and obj1.rotation are PyTorch tensors</span>
    <span class="nb">print</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;obj1.translation is now a </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">obj1</span><span class="o">.</span><span class="n">translation</span><span class="p">)</span><span class="si">}</span><span class="s2"> with shape </span><span class="si">{</span><span class="n">obj1</span><span class="o">.</span><span class="n">translation</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;obj1.rotation is now a </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">obj1</span><span class="o">.</span><span class="n">rotation</span><span class="p">)</span><span class="si">}</span><span class="s2"> with shape </span><span class="si">{</span><span class="n">obj1</span><span class="o">.</span><span class="n">rotation</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="p">)</span>

    <span class="c1"># Example with motion data (using MeshSceneObject)</span>
    <span class="n">obj2</span> <span class="o">=</span> <span class="n">MeshSceneObject</span><span class="p">(</span>
        <span class="n">object_path</span><span class="o">=</span><span class="s2">&quot;examples/data/armchair.urdf&quot;</span><span class="p">,</span>
        <span class="n">translation</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]]),</span>
        <span class="n">rotation</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]]</span>
        <span class="p">),</span>
        <span class="n">fps</span><span class="o">=</span><span class="mf">30.0</span><span class="p">,</span>  <span class="c1"># Required for motion</span>
        <span class="n">options</span><span class="o">=</span><span class="n">ObjectOptions</span><span class="p">(</span>
            <span class="n">vhacd_enabled</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">vhacd_params</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;resolution&quot;</span><span class="p">:</span> <span class="mi">50000</span><span class="p">},</span> <span class="n">fix_base_link</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">),</span>
    <span class="p">)</span>

    <span class="c1"># Create a primitive box</span>
    <span class="n">obj3</span> <span class="o">=</span> <span class="n">BoxSceneObject</span><span class="p">(</span>
        <span class="n">width</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">depth</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">height</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">translation</span><span class="o">=</span><span class="p">(</span><span class="mf">3.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">),</span>
        <span class="n">rotation</span><span class="o">=</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span>
        <span class="n">options</span><span class="o">=</span><span class="n">ObjectOptions</span><span class="p">(</span><span class="n">fix_base_link</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
    <span class="p">)</span>

    <span class="n">scene1</span> <span class="o">=</span> <span class="n">Scene</span><span class="p">(</span><span class="n">objects</span><span class="o">=</span><span class="p">[</span><span class="n">obj1</span><span class="p">,</span> <span class="n">obj3</span><span class="p">])</span>

    <span class="n">obj4</span> <span class="o">=</span> <span class="n">MeshSceneObject</span><span class="p">(</span>
        <span class="n">object_path</span><span class="o">=</span><span class="s2">&quot;examples/data/elephant.stl&quot;</span><span class="p">,</span>
        <span class="n">translation</span><span class="o">=</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
        <span class="n">rotation</span><span class="o">=</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span>
        <span class="n">options</span><span class="o">=</span><span class="n">ObjectOptions</span><span class="p">(</span>
            <span class="n">vhacd_enabled</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">vhacd_params</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;resolution&quot;</span><span class="p">:</span> <span class="mi">50000</span><span class="p">},</span> <span class="n">fix_base_link</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">),</span>
    <span class="p">)</span>
    <span class="n">obj5</span> <span class="o">=</span> <span class="n">MeshSceneObject</span><span class="p">(</span>
        <span class="n">object_path</span><span class="o">=</span><span class="s2">&quot;examples/data/armchair.obj&quot;</span><span class="p">,</span>
        <span class="n">translation</span><span class="o">=</span><span class="p">(</span><span class="mf">2.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
        <span class="n">rotation</span><span class="o">=</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span>
        <span class="n">options</span><span class="o">=</span><span class="n">ObjectOptions</span><span class="p">(</span>
            <span class="n">vhacd_enabled</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">vhacd_params</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;resolution&quot;</span><span class="p">:</span> <span class="mi">50000</span><span class="p">},</span> <span class="n">fix_base_link</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">),</span>
    <span class="p">)</span>
    <span class="n">scene2</span> <span class="o">=</span> <span class="n">Scene</span><span class="p">(</span><span class="n">objects</span><span class="o">=</span><span class="p">[</span><span class="n">obj4</span><span class="p">,</span> <span class="n">obj5</span><span class="p">])</span>

    <span class="n">scenes</span> <span class="o">=</span> <span class="p">[</span><span class="n">scene1</span><span class="p">,</span> <span class="n">scene2</span><span class="p">]</span>

    <span class="n">terrain</span> <span class="o">=</span> <span class="n">DummyTerrain</span><span class="p">()</span>
    
    <span class="c1"># Create config</span>
    <span class="n">scene_lib_config</span> <span class="o">=</span> <span class="n">SceneLibConfig</span><span class="p">(</span>
        <span class="n">scene_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">replicate_method</span><span class="o">=</span><span class="n">ReplicationMethod</span><span class="o">.</span><span class="n">RANDOM</span><span class="p">,</span>
        <span class="n">subset_method</span><span class="o">=</span><span class="n">SubsetMethod</span><span class="o">.</span><span class="n">FIRST</span><span class="p">,</span>
        <span class="n">pointcloud_samples_per_object</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span>
    
    <span class="c1"># Create SceneLib</span>
    <span class="n">scene_lib</span> <span class="o">=</span> <span class="n">SceneLib</span><span class="p">(</span>
        <span class="n">config</span><span class="o">=</span><span class="n">scene_lib_config</span><span class="p">,</span>
        <span class="n">num_envs</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
        <span class="n">scenes</span><span class="o">=</span><span class="n">scenes</span><span class="p">,</span>
        <span class="n">device</span><span class="o">=</span><span class="s2">&quot;cpu&quot;</span><span class="p">,</span>
        <span class="n">terrain</span><span class="o">=</span><span class="n">terrain</span>
    <span class="p">)</span>
    
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">scene</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">scene_lib</span><span class="o">.</span><span class="n">scenes</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Environment </span><span class="si">%d</span><span class="s2"> assigned Scene with objects </span><span class="si">%s</span><span class="s2"> with offset </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">idx</span><span class="p">,</span>
            <span class="n">scene</span><span class="o">.</span><span class="n">objects</span><span class="p">,</span>
            <span class="n">scene</span><span class="o">.</span><span class="n">offset</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="c1"># get_object_pose returns an ObjectState</span>
    <span class="n">time</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mi">30</span> <span class="o">*</span> <span class="mf">0.5</span>
    <span class="n">pose_obj0</span> <span class="o">=</span> <span class="n">scene_lib</span><span class="o">.</span><span class="n">get_object_pose</span><span class="p">(</span>
        <span class="n">object_indices</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mi">0</span><span class="p">]),</span> <span class="n">time</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="n">time</span><span class="p">])</span>
    <span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
        <span class="s2">&quot;Pose for object at index 0 at time </span><span class="si">%s</span><span class="s2">:</span><span class="se">\n</span><span class="s2">Translations: </span><span class="si">%s</span><span class="se">\n</span><span class="s2">Rotations: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="n">time</span><span class="p">,</span>
        <span class="n">pose_obj0</span><span class="o">.</span><span class="n">root_pos</span><span class="p">,</span>
        <span class="n">pose_obj0</span><span class="o">.</span><span class="n">root_rot</span><span class="p">,</span>
    <span class="p">)</span>
</pre></div>
        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2025, Chen Tessler, Yifeng Jiang, Erwin Coumans, Haotian Zhang, Davis Rempe, Xue Bin Peng, Sanja Fidler, and Gal Chechik
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </div>
</div><script src="../../../_static/documentation_options.js?v=8a448e45"></script>
    <script src="../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/scripts/furo.js?v=46bd48cc"></script>
    <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../../_static/copybutton.js?v=30646c52"></script>
    </body>
</html>